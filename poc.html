<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Octopath Agentic Prototype - Full Sim</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background-color: #1a1a2e; color: #eee; font-family: 'Inter', sans-serif; overflow: hidden; }
        canvas { display: block; }
        .pixel-text { font-family: 'Courier New', Courier, monospace; }
        .thought-bubble {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            border: 2px solid #222;
            box-shadow: 6px 6px 0px rgba(0,0,0,0.15);
            color: #111;
        }
        #ui-root { text-rendering: pixelated; }
        .agent-log-item { border-left: 4px solid transparent; transition: all 0.3s; padding-left: 10px; margin-bottom: 4px; }
        .agent-log-item.active { border-left-color: #f97316; background: rgba(249, 115, 22, 0.1); }
        .agent-log-item.danger { border-left-color: #ef4444; background: rgba(239, 68, 68, 0.15); font-weight: 800; }
        
        /* High Visibility Dialogue */
        .dialogue-box {
            position: absolute;
            padding: 8px 12px;
            background: #fffbe6; /* Old paper color */
            border: 3px solid #2d241e;
            box-shadow: 4px 4px 0px rgba(0,0,0,0.3);
            font-size: 14px;
            font-family: 'Courier New', Courier, monospace;
            font-weight: 900;
            color: #2d241e;
            border-radius: 2px;
            pointer-events: none;
            transform: translate(-50%, -100%);
            white-space: nowrap;
            z-index: 50;
        }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div id="ui-root" class="absolute inset-0 pointer-events-none z-10 flex flex-col justify-between p-6">
        <!-- Top Bar -->
        <div class="flex justify-between items-start">
            <div class="thought-bubble p-4 rounded-sm border-orange-500 border-l-8">
                <h1 class="text-xs uppercase tracking-widest text-orange-600 font-black mb-1">Simulated Realm v4.0</h1>
                <p class="text-sm pixel-text font-bold">Current Event: <span id="event-tag" class="text-blue-600">Peaceful Day</span></p>
                <div class="flex gap-4 mt-2">
                    <div class="text-[10px] uppercase font-bold text-neutral-500">Entities: <span id="entity-count" class="text-orange-600">--</span></div>
                    <div class="text-[10px] uppercase font-bold text-neutral-500">Quest Items: <span class="text-purple-600" id="quest-count">0</span></div>
                </div>
            </div>
            
            <div id="danger-warning" class="hidden thought-bubble px-6 py-3 rounded-full flex items-center gap-3 border-none bg-red-600 text-white shadow-lg animate-bounce">
                <div class="w-3 h-3 rounded-full bg-white animate-ping"></div>
                <span class="text-xs uppercase font-black tracking-widest">Monster Detected!</span>
            </div>
        </div>

        <!-- Agent Thought -->
        <div id="agent-display" class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-72 text-center transition-all duration-500 opacity-0 scale-90">
            <div class="thought-bubble p-4 rounded-lg max-w-sm relative border-4 border-orange-400">
                <div class="text-[10px] uppercase font-black text-orange-500 mb-1" id="agent-name-tag">Hero</div>
                <div id="agent-thought" class="text-sm font-bold italic text-neutral-800 leading-tight">"..."</div>
                <div class="absolute -bottom-3 left-1/2 -translate-x-1/2 w-6 h-6 rotate-45 bg-white border-r-4 border-b-4 border-orange-400"></div>
            </div>
        </div>

        <!-- Log Stream -->
        <div class="w-full max-w-xl mx-auto mb-4">
            <div class="thought-bubble p-4 rounded-lg border-2 border-black/10">
                <div class="flex items-center justify-between mb-2">
                    <span class="text-[10px] uppercase font-black text-orange-600">Chaos Log & Reason Stream</span>
                    <span class="text-[10px] opacity-40 font-bold" id="sim-time">00:00:00</span>
                </div>
                <div id="log-container" class="h-40 overflow-y-auto text-[11px] pixel-text space-y-1 font-bold pr-2">
                    <!-- Logs injected here -->
                </div>
            </div>
        </div>
    </div>

    <div id="dialogue-layer" class="absolute inset-0 pointer-events-none"></div>

    <!-- Controls -->
    <div class="absolute bottom-6 right-6 z-20 flex flex-col gap-3 pointer-events-auto">
        <button onclick="cycleCamera()" class="thought-bubble p-4 rounded-lg hover:bg-orange-100 transition-all cursor-pointer bg-white">
            <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z" /></svg>
        </button>
        <button onclick="spawnMonster()" class="thought-bubble p-4 rounded-lg hover:bg-red-500 hover:text-white transition-all cursor-pointer bg-white border-red-500 text-red-500">
            <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
        </button>
        <button onclick="triggerGlobalThink()" class="thought-bubble p-4 rounded-lg hover:scale-105 transition-all cursor-pointer bg-orange-500 text-white border-none shadow-xl">
            <svg xmlns="http://www.w3.org/2000/svg" class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24"><path d="M13 10V3L4 14h7v7l9-11h-7z" /></svg>
        </button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/examples/jsm/postprocessing/EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
                "three/examples/jsm/postprocessing/RenderPass": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
                "three/examples/jsm/postprocessing/UnrealBloomPass": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js",
                "three/examples/jsm/postprocessing/BokehPass": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/BokehPass.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass';
        import { BokehPass } from 'three/examples/jsm/postprocessing/BokehPass';

        // --- CONFIG & ASSETS ---
        const SPRITES = {
            HERO_RED: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/37.png',
            HERO_YELLOW: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/25.png',
            HERO_EEVEE: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/133.png',
            NPC_MAN: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/122.png',
            ANIMAL_BIRD: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/16.png',
            MONSTER: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/94.png', // Gengar
            FOOD: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/items/berry.png',
            IDOL: 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/items/nugget.png'
        };

        const FUNNY_LINES = [
            "It is a terrifying carp.", 
            "I like turtles for their shells.", 
            "The weather is... suboptimal.", 
            "I have an urge to dig a hole.", 
            "My knees are 34% more arthritic today.",
            "Urist is throwing a tantrum!",
            "Who left this rock here? It's vulgar.",
            "I'm 80% sure I'm a simulation.",
            "Cats are liquid. It's proven physics.",
            "I crave a very specific kind of berry."
        ];

        let scene, camera, renderer, composer, worldGroup, groundMesh;
        let viewMode = 0; 
        let entities = [];
        let poiList = [];
        const loader = new THREE.TextureLoader();
        const raycaster = new THREE.Raycaster();

        // --- INITIALIZATION ---
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xffe4b5, 0.012);
            scene.background = new THREE.Color(0xfff5e6);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 40);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 1.0));
            const sun = new THREE.DirectionalLight(0xffe0ac, 2.5);
            sun.position.set(30, 60, 30);
            sun.castShadow = true;
            sun.shadow.camera.left = -60; sun.shadow.camera.right = 60;
            sun.shadow.camera.top = 60; sun.shadow.camera.bottom = -60;
            sun.shadow.mapSize.set(2048, 2048);
            scene.add(sun);

            worldGroup = new THREE.Group();
            scene.add(worldGroup);

            setupTerrain();
            setupLandmarks(); // Stonehenge etc
            spawnQuestItems();
            spawnEntities();
            setupPostProcessing();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // --- TERRAIN ---
        function setupTerrain() {
            const size = 120;
            const segments = 45;
            const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
            const positionAttribute = geometry.getAttribute('position');
            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);
                const z = Math.sin(x * 0.08) * 3 + Math.cos(y * 0.12) * 3;
                positionAttribute.setZ(i, z);
            }
            geometry.computeVertexNormals();

            const grassTex = loader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
            grassTex.magFilter = THREE.NearestFilter;
            grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
            grassTex.repeat.set(20, 20);

            groundMesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ map: grassTex, color: 0x99cc44 }));
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            worldGroup.add(groundMesh);
        }

        function getGroundHeight(x, z) {
            raycaster.set(new THREE.Vector3(x, 30, z), new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObject(groundMesh);
            if (intersects.length > 0) return intersects[0].point.y;
            return 0;
        }

        // --- LANDMARKS ---
        function setupLandmarks() {
            // Stonehenge (Chat Area)
            const hX = -15, hZ = -15;
            poiList.push({ name: "Stonehenge", pos: new THREE.Vector3(hX, 0, hZ), radius: 6 });
            
            for(let i = 0; i < 8; i++) {
                const ang = (i / 8) * Math.PI * 2;
                const rock = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 5 + Math.random()*2, 1.5),
                    new THREE.MeshStandardMaterial({ color: 0x777777 })
                );
                const rx = hX + Math.cos(ang) * 5;
                const rz = hZ + Math.sin(ang) * 5;
                rock.position.set(rx, getGroundHeight(rx, rz) + 2.5, rz);
                rock.rotation.y = ang;
                rock.castShadow = true;
                worldGroup.add(rock);
            }

            // Scattered Trees
            for(let i = 0; i < 60; i++) {
                const tx = (Math.random()-0.5)*100;
                const tz = (Math.random()-0.5)*100;
                const tree = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 6), new THREE.MeshStandardMaterial({color: 0x442211}));
                tree.position.set(tx, getGroundHeight(tx, tz) + 3, tz);
                tree.castShadow = true;
                worldGroup.add(tree);
            }
        }

        function spawnQuestItems() {
            for(let i = 0; i < 15; i++) {
                const ix = (Math.random()-0.5)*90;
                const iz = (Math.random()-0.5)*90;
                const iy = getGroundHeight(ix, iz) + 0.5;
                const type = Math.random() > 0.5 ? 'FOOD' : 'IDOL';
                
                const tex = loader.load(SPRITES[type]);
                tex.magFilter = THREE.NearestFilter;
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), new THREE.MeshStandardMaterial({ map: tex, transparent: true, alphaTest: 0.1 }));
                mesh.position.set(ix, iy, iz);
                mesh.onBeforeRender = function() { this.rotation.y = camera.rotation.y; };
                worldGroup.add(mesh);
                poiList.push({ name: type, pos: new THREE.Vector3(ix, iy, iz), mesh, active: true });
            }
            document.getElementById('quest-count').innerText = poiList.filter(p => p.active && p.name !== "Stonehenge").length;
        }

        // --- ENTITY LOGIC ---
        function spawnEntities() {
            addEntity('Urist', SPRITES.HERO_RED, 'HERO', new THREE.Vector3(0,0,0));
            addEntity('Blinky', SPRITES.HERO_YELLOW, 'HERO', new THREE.Vector3(10,0,10));
            addEntity('Floof', SPRITES.HERO_EEVEE, 'HERO', new THREE.Vector3(-10,0,5));
            for(let i = 0; i < 4; i++) addEntity(`Pleb ${i}`, SPRITES.NPC_MAN, 'NPC');
            for(let i = 0; i < 5; i++) addEntity('Bird', SPRITES.ANIMAL_BIRD, 'ANIMAL');
        }

        function addEntity(name, url, type, pos = null) {
            const tex = loader.load(url);
            tex.magFilter = THREE.NearestFilter;
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(2, 2),
                new THREE.MeshStandardMaterial({ map: tex, transparent: true, alphaTest: 0.1, side: THREE.DoubleSide })
            );
            const startX = pos ? pos.x : (Math.random()-0.5)*60;
            const startZ = pos ? pos.z : (Math.random()-0.5)*60;
            mesh.position.set(startX, getGroundHeight(startX, startZ) + 1, startZ);
            mesh.castShadow = true;
            scene.add(mesh);

            const entity = {
                name, type, mesh,
                target: new THREE.Vector3(mesh.position.x, 0, mesh.position.z),
                state: 'WANDER', timer: 3, walkPhase: 0,
                speed: type === 'HERO' ? 0.09 : (type === 'NPC' ? 0.05 : 0.12),
                dialogueCooldown: 0, isTalking: false, talkTimer: 0,
                isFleeing: false,
                
                update(delta, time) {
                    this.mesh.rotation.y = Math.atan2(camera.position.x - this.mesh.position.x, camera.position.z - this.mesh.position.z);
                    
                    if(this.isTalking) {
                        this.talkTimer -= delta;
                        if(this.talkTimer <= 0) this.isTalking = false;
                        return;
                    }

                    // MONSTER DETECTION
                    const monster = entities.find(e => e.type === 'MONSTER');
                    if (monster && this.type !== 'MONSTER' && this.mesh.position.distanceTo(monster.mesh.position) < 8) {
                        this.isFleeing = true;
                        this.state = 'FLEE';
                        this.target.copy(this.mesh.position).sub(monster.mesh.position).normalize().multiplyScalar(10).add(this.mesh.position);
                    } else {
                        this.isFleeing = false;
                    }

                    this.timer -= delta;
                    this.dialogueCooldown -= delta;

                    if(this.timer <= 0 && !this.isFleeing) {
                        this.timer = 5 + Math.random() * 5;
                        const dice = Math.random();
                        if(dice < 0.4) {
                            this.state = 'WANDER';
                            // Weighted Target: Go to POI
                            const activePOIs = poiList.filter(p => p.active);
                            const poi = activePOIs[Math.floor(Math.random()*activePOIs.length)];
                            this.target.copy(poi.pos).add(new THREE.Vector3((Math.random()-0.5)*3, 0, (Math.random()-0.5)*3));
                        } else {
                            this.state = 'IDLE';
                        }
                    }

                    if(this.state === 'WANDER' || this.state === 'FLEE') {
                        const dist = new THREE.Vector2(this.target.x - this.mesh.position.x, this.target.z - this.mesh.position.z).length();
                        const s = this.isFleeing ? this.speed * 2 : this.speed;
                        if(dist > 0.4) {
                            const ang = Math.atan2(this.target.z - this.mesh.position.z, this.target.x - this.mesh.position.x);
                            const nx = this.mesh.position.x + Math.cos(ang) * s;
                            const nz = this.mesh.position.z + Math.sin(ang) * s;
                            this.mesh.position.set(nx, getGroundHeight(nx, nz) + 1, nz);
                            
                            this.walkPhase += delta * (this.isFleeing ? 25 : 12);
                            this.mesh.rotation.z = Math.cos(this.walkPhase) * 0.15;
                            this.mesh.position.y += Math.abs(Math.sin(this.walkPhase)) * 0.1;
                        } else {
                            this.state = 'IDLE';
                            this.checkQuestPickup();
                        }
                    } else {
                        this.mesh.position.y = getGroundHeight(this.mesh.position.x, this.mesh.position.z) + 1 + Math.sin(time*2)*0.05;
                        this.mesh.rotation.z = 0;
                    }
                },

                checkQuestPickup() {
                    poiList.forEach(poi => {
                        if(poi.active && poi.name !== "Stonehenge" && this.mesh.position.distanceTo(poi.pos) < 2) {
                            poi.active = false;
                            poi.mesh.visible = false;
                            addLog(`[${this.name}] found a ${poi.name}! Reason: "It sparked joy."`, "active");
                            document.getElementById('quest-count').innerText = poiList.filter(p => p.active && p.name !== "Stonehenge").length;
                        }
                    });
                }
            };
            entities.push(entity);
            document.getElementById('entity-count').innerText = entities.length;
        }

        // --- MONSTER ---
        window.spawnMonster = () => {
            if(entities.some(e => e.type === 'MONSTER')) return;
            
            const mx = 30, mz = 30;
            const tex = loader.load(SPRITES.MONSTER);
            tex.magFilter = THREE.NearestFilter;
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 3.5), new THREE.MeshStandardMaterial({ map: tex, transparent: true, side: THREE.DoubleSide }));
            mesh.position.set(mx, getGroundHeight(mx, mz) + 1.5, mz);
            mesh.castShadow = true;
            scene.add(mesh);

            const monster = {
                name: "The Void-Gengar", type: 'MONSTER', mesh, speed: 0.18, timer: 20,
                update(delta, time) {
                    this.mesh.rotation.y = Math.atan2(camera.position.x - this.mesh.position.x, camera.position.z - this.mesh.position.z);
                    this.timer -= delta;
                    
                    // Hunt nearest non-monster
                    let nearest = null; let minDist = Infinity;
                    entities.forEach(e => {
                        if(e.type !== 'MONSTER') {
                            const d = e.mesh.position.distanceTo(this.mesh.position);
                            if(d < minDist) { minDist = d; nearest = e; }
                        }
                    });

                    if(nearest) {
                        const ang = Math.atan2(nearest.mesh.position.z - this.mesh.position.z, nearest.mesh.position.x - this.mesh.position.x);
                        this.mesh.position.x += Math.cos(ang) * this.speed;
                        this.mesh.position.z += Math.sin(ang) * this.speed;
                        this.mesh.position.y = getGroundHeight(this.mesh.position.x, this.mesh.position.z) + 1.5 + Math.sin(time*5)*0.2;
                        
                        if(minDist < 1.5) {
                            addLog(`[CRITICAL] ${nearest.name} was devoured!`, "danger");
                            removeEntity(nearest);
                        }
                    }

                    if(this.timer <= 0) {
                        addLog("The monster has returned to the digital void.", "active");
                        removeEntity(this);
                    }
                }
            };
            entities.push(monster);
            document.getElementById('danger-warning').classList.remove('hidden');
            document.getElementById('event-tag').innerText = "MONSTER ATTACK";
            document.getElementById('event-tag').className = "text-red-600 font-black";
        };

        function removeEntity(ent) {
            scene.remove(ent.mesh);
            entities = entities.filter(e => e !== ent);
            document.getElementById('entity-count').innerText = entities.length;
            if(!entities.some(e => e.type === 'MONSTER')) {
                document.getElementById('danger-warning').classList.add('hidden');
                document.getElementById('event-tag').innerText = "Peaceful Day";
                document.getElementById('event-tag').className = "text-blue-600";
            }
        }

        // --- SOCIAL ---
        function checkSocial() {
            for(let i=0; i<entities.length; i++) {
                const a = entities[i];
                if(a.type === 'ANIMAL' || a.type === 'MONSTER' || a.dialogueCooldown > 0 || a.isTalking) continue;
                for(let j=i+1; j<entities.length; j++) {
                    const b = entities[j];
                    if(b.type === 'ANIMAL' || b.type === 'MONSTER' || b.dialogueCooldown > 0 || b.isTalking) continue;
                    if(a.mesh.position.distanceTo(b.mesh.position) < 4) {
                        a.isTalking = b.isTalking = true;
                        a.talkTimer = b.talkTimer = 4;
                        a.dialogueCooldown = b.dialogueCooldown = 20;
                        const line = FUNNY_LINES[Math.floor(Math.random()*FUNNY_LINES.length)];
                        showBubble(a, line);
                        showBubble(b, "I concur. " + (Math.random()*100).toFixed(0) + "% logic.");
                        break;
                    }
                }
            }
        }

        function showBubble(ent, text) {
            const b = document.createElement('div');
            b.className = 'dialogue-box';
            b.innerText = text;
            document.getElementById('dialogue-layer').appendChild(b);
            const up = () => {
                if(!ent.isTalking) { b.remove(); return; }
                const v = ent.mesh.position.clone().project(camera);
                b.style.left = `${(v.x+1)/2*window.innerWidth}px`;
                b.style.top = `${-(v.y-1)/2*window.innerHeight - 80}px`;
                requestAnimationFrame(up);
            };
            up();
        }

        function addLog(txt, cls="") {
            const l = document.getElementById('log-container');
            const d = document.createElement('div');
            d.className = "agent-log-item " + cls;
            d.innerText = `> ${txt}`;
            l.prepend(d);
            setTimeout(() => d.classList.remove('active'), 3000);
        }

        // --- CAMERA & LOOP ---
        function cycleCamera() {
            viewMode = (viewMode + 1) % 4;
            addLog(`Focal point: ${viewMode === 0 ? 'Cinematic' : entities[viewMode-1].name}`);
        }

        window.triggerGlobalThink = () => {
            const h = entities.filter(e => e.type === 'HERO');
            const a = h[Math.floor(Math.random()*h.length)];
            const d = document.getElementById('agent-display');
            document.getElementById('agent-name-tag').innerText = a.name;
            document.getElementById('agent-thought').innerText = FUNNY_LINES[Math.floor(Math.random()*FUNNY_LINES.length)];
            d.style.opacity = '1';
            d.style.transform = 'translate(-50%, -20px) scale(1)';
            setTimeout(() => { d.style.opacity='0'; d.style.transform='translate(-50%, 0) scale(0.9)'; }, 4000);
        };

        function setupPostProcessing() {
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(new BokehPass(scene, camera, { focus: 25.0, aperture: 0.00003, maxblur: 0.01 }));
            composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.3, 0.4, 0.9));
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            const delta = 0.016;

            entities.forEach(e => e.update(delta, time));
            checkSocial();

            if(viewMode === 0) {
                camera.position.x = Math.sin(time*0.06)*45;
                camera.position.z = Math.cos(time*0.06)*45;
                camera.position.y = 25 + Math.sin(time*0.1)*5;
                camera.lookAt(0, 0, 0);
            } else {
                const h = entities[viewMode-1];
                if(h) {
                    const ideal = h.mesh.position.clone().add(new THREE.Vector3(0, 15, 20));
                    camera.position.lerp(ideal, 0.05);
                    camera.lookAt(h.mesh.position);
                } else viewMode = 0;
            }

            composer.render();
            document.getElementById('sim-time').innerText = new Date().toTimeString().split(' ')[0];
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        window.cycleCamera = cycleCamera;
        window.onload = init;
    </script>
</body>
</html>