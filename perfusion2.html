<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vascular Perfusion Engine</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Rajdhani:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #05070a;
            --panel-bg: rgba(10, 15, 20, 0.85);
            --panel-border: rgba(0, 243, 255, 0.2);
            --primary: #00f3ff;
            --primary-dim: rgba(0, 243, 255, 0.1);
            --secondary: #ff2a2a;
            --text-main: #e0f0ff;
            --text-muted: #64748b;
            --grid-color: rgba(255, 255, 255, 0.03);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            /* Improved Gradient Background - Deeper and smoother */
            background: radial-gradient(circle at center, #1c2e3f 0%, #0f161d 45%, #000000 100%);
            font-family: 'Rajdhani', sans-serif;
            color: var(--text-main);
            user-select: none;
        }

        /* --- POST-PROCESSING SCANLINES --- */
        body::after {
            content: "";
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.4;
        }

        /* --- UI LAYOUT --- */
        #ui-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: grid;
            grid-template-rows: 60px 1fr 40px;
            grid-template-columns: 360px 1fr;
            grid-template-areas: 
                "header header"
                "sidebar viewport"
                "footer footer";
            z-index: 10;
        }

        /* --- HEADER --- */
        header {
            grid-area: header;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 25px;
            background: linear-gradient(180deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
            border-bottom: 1px solid var(--panel-border);
            pointer-events: auto;
        }
        .app-title {
            font-size: 24px; font-weight: 700; letter-spacing: 2px;
            text-shadow: 0 0 10px var(--primary);
            display: flex; align-items: center; gap: 15px;
        }
        .status-badge {
            font-family: 'JetBrains Mono', monospace; font-size: 10px;
            background: var(--primary-dim); color: var(--primary);
            padding: 4px 8px; border: 1px solid var(--primary); border-radius: 2px;
        }

        /* --- SIDEBAR --- */
        #sidebar {
            grid-area: sidebar;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-right: 1px solid var(--panel-border);
            padding: 20px;
            overflow-y: auto;
            pointer-events: auto;
            display: flex; flex-direction: column; gap: 25px;
            box-shadow: 10px 0 30px rgba(0,0,0,0.5);
        }

        .panel-section { position: relative; }
        .panel-header {
            font-size: 14px; color: var(--primary); letter-spacing: 2px;
            text-transform: uppercase; margin-bottom: 15px;
            display: flex; align-items: center; gap: 10px;
            cursor: pointer; /* For collapsible sections */
        }
        .panel-header::after { content: ''; height: 1px; flex-grow: 1; background: linear-gradient(90deg, var(--primary) 0%, transparent 100%); opacity: 0.5; }

        /* Documentation Panel */
        #doc-content {
            font-size: 11px; line-height: 1.5; color: var(--text-muted);
            background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.05);
            display: none;
        }
        #doc-content.open { display: block; }
        #doc-content strong { color: var(--text-main); }

        /* --- CONTROLS --- */
        .control-group { margin-bottom: 15px; }
        .label-row { 
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 5px; font-size: 12px; font-weight: 600; color: var(--text-muted); 
            position: relative;
        }
        .value-display { font-family: 'JetBrains Mono', monospace; color: var(--primary); }

        /* Tooltips */
        .help-icon {
            display: inline-flex; align-items: center; justify-content: center;
            width: 14px; height: 14px; border-radius: 50%;
            background: rgba(255,255,255,0.1); color: var(--text-muted);
            font-size: 9px; cursor: help; margin-left: 6px;
            transition: 0.2s;
        }
        .help-icon:hover { background: var(--primary); color: #000; }
        
        .tooltip {
            position: absolute; bottom: 100%; left: 0; width: 100%;
            background: #0f161d; border: 1px solid var(--primary);
            color: #e0f0ff; padding: 8px; border-radius: 4px;
            font-size: 10px; line-height: 1.4; font-weight: normal;
            z-index: 100; pointer-events: none;
            opacity: 0; visibility: hidden; transform: translateY(5px);
            transition: all 0.2s ease; box-shadow: 0 5px 15px rgba(0,0,0,0.8);
        }
        .help-icon:hover + .tooltip, .label-row:hover .tooltip {
            opacity: 1; visibility: visible; transform: translateY(0);
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; cursor: pointer;
            background: rgba(255,255,255,0.1); border-radius: 2px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 6px;
            background: var(--primary); margin-top: -6px;
            box-shadow: 0 0 10px var(--primary); cursor: pointer;
            border-radius: 1px; transition: 0.2s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scaleY(1.2); background: #fff; }

        /* Tech Buttons */
        .btn-tech {
            width: 100%; padding: 12px;
            background: linear-gradient(90deg, rgba(0,243,255,0.05) 0%, transparent 100%);
            border: 1px solid var(--panel-border);
            color: var(--primary);
            font-family: 'Rajdhani', sans-serif; font-weight: 700; font-size: 14px; letter-spacing: 1px;
            text-transform: uppercase; cursor: pointer;
            position: relative; overflow: hidden;
            transition: all 0.3s ease;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        .btn-tech::before {
            content: ''; position: absolute; left: 0; bottom: 0; width: 100%; height: 2px;
            background: var(--primary); transform: scaleX(0); transform-origin: left; transition: 0.3s;
        }
        .btn-tech:hover:not(:disabled) { background: rgba(0,243,255,0.15); box-shadow: 0 0 15px rgba(0,243,255,0.2); }
        .btn-tech:hover::before { transform: scaleX(1); }
        .btn-tech:disabled { opacity: 0.3; cursor: not-allowed; filter: grayscale(1); }
        
        .btn-danger { color: var(--secondary); border-color: rgba(255, 42, 42, 0.3); }
        .btn-danger:hover { background: rgba(255, 42, 42, 0.15); box-shadow: 0 0 15px rgba(255, 42, 42, 0.2); }

        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }

        /* Inlet List */
        #inlets-list { display: flex; flex-direction: column; gap: 8px; margin-bottom: 10px; }
        .inlet-item {
            display: flex; align-items: center; justify-content: space-between;
            background: rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.05);
            padding: 8px 12px; font-size: 12px;
            cursor: pointer; transition: 0.2s;
        }
        .inlet-item:hover { border-color: var(--primary); }
        .inlet-item.active { border-color: var(--primary); background: rgba(0, 243, 255, 0.05); }
        .inlet-item .del { color: var(--secondary); font-weight: bold; padding: 4px; }
        .inlet-item .del:hover { color: #fff; }

        /* --- FOOTER --- */
        footer {
            grid-area: footer;
            background: var(--panel-bg);
            border-top: 1px solid var(--panel-border);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; font-family: 'JetBrains Mono', monospace; font-size: 10px;
            color: var(--text-muted); pointer-events: auto;
        }
        .metric { display: flex; gap: 10px; align-items: center; }
        .metric span { color: var(--primary); }

        /* --- LOADING OVERLAY --- */
        #loading {
            position: absolute; inset: 0; background: #000; z-index: 2000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: opacity 0.5s; pointer-events: none; opacity: 0;
        }
        #loading.active { opacity: 1; pointer-events: auto; }
        .loader-bar {
            width: 200px; height: 2px; background: #333; margin-top: 20px; position: relative; overflow: hidden;
        }
        .loader-bar::after {
            content: ''; position: absolute; top: 0; left: 0; height: 100%; width: 50%;
            background: var(--primary); animation: load 1s infinite linear;
        }
        @keyframes load { 0% { left: -50%; } 100% { left: 100%; } }

        /* --- 3D CANVAS --- */
        canvas { outline: none; }
    </style>
    
    <!-- Three.js & Post Processing -->
    <script type="importmap">
        { "imports": { 
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", 
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" 
        } }
    </script>
</head>
<body>

<!-- UI OVERLAY -->
<div id="ui-container">
    <header>
        <div class="app-title">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#00f3ff" stroke-width="2">
                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path>
            </svg>
            VASCULAR PERFUSION ENGINE
        </div>
        <div class="status-badge" id="system-status">Visualization</div>
    </header>

    <div id="sidebar">
        <!-- Section 0: Info -->
        <div class="panel-section">
            <div class="panel-header" onclick="document.getElementById('doc-content').classList.toggle('open')">00 // SYSTEM ARCHITECTURE <span style="font-size:10px; opacity:0.5; margin-left:auto">â–¼</span></div>
            <div id="doc-content">
                <strong>Simplex Noise Volume:</strong> Generates organic, non-uniform tissue shapes by perturbing a sphere mesh.<br><br>
                <strong>Constructive Optimization:</strong> Uses Dijkstra's algorithm to find optimal paths from inlets to target tissues. Repeated flow reinforces paths, turning them into arteries (Adaptive Conductivity).<br><br>
                <strong>Murray's Law:</strong> Vessel radii are scaled ($r^3 = \sum r_{child}^3$) to mimic biological energy conservation.<br><br>
                <strong>CFD Particle Flow:</strong> Visualizes hemodynamics. Speed is proportional to $Radius^{1.5} / Length$, simulating fluid momentum.
            </div>
        </div>

        <!-- Section 1: Mesh -->
        <div class="panel-section">
            <div class="panel-header">01 // VOLUME SYNTHESIS</div>
            
            <div class="control-group">
                <div class="label-row">
                    <span>IRREGULARITY NOISE</span>
                    <div class="help-icon">?</div>
                    <div class="tooltip">Amplitude of the simplex noise used to deform the organ mesh. Higher values create weirder, more organic shapes.</div>
                    <span id="v-noise" class="value-display">0.7</span>
                </div>
                <input type="range" id="i-noise" min="0" max="1.5" step="0.1" value="0.7">
            </div>

            <!-- New Point Count Setting -->
            <div class="control-group">
                <div class="label-row">
                    <span>TISSUE RESOLUTION</span>
                    <div class="help-icon">?</div>
                    <div class="tooltip">Total number of tissue nodes (voxels) generated inside the mesh. Higher count = more dense and detailed vascular tree (Heavier on CPU).</div>
                    <span id="v-points" class="value-display">3000</span>
                </div>
                <input type="range" id="i-points" min="1000" max="10000" step="500" value="3000">
            </div>

            <div class="btn-group">
                <button class="btn-tech" onclick="run(genVolume)">GENERATE VOLUME</button>
                <button class="btn-tech" onclick="document.getElementById('file-input').click()">UPLOAD STL</button>
            </div>
            <input type="file" id="file-input" style="display:none" accept=".stl" onchange="handleFileUpload(event)">
            
            <div style="margin-top: 15px; display: flex; align-items: center; gap: 10px; font-size: 12px;">
                <input type="checkbox" id="c-pts" checked onchange="togglePoints()" style="accent-color: var(--primary);">
                <label for="c-pts" style="color: var(--text-muted); cursor: pointer;">SHOW TISSUE GRID</label>
            </div>
        </div>

        <!-- Section 2: Inlets -->
        <div class="panel-section">
            <div class="panel-header">02 // PERFUSION SOURCES</div>
            <div id="inlets-list"></div>
            <button class="btn-tech" id="btn-add-inlet" onclick="addInlet()">+ ADD INLET SOURCE</button>
            <p style="font-size: 11px; color: var(--text-muted); margin-top: 8px; line-height: 1.4;">
                <span style="color: var(--primary);">INSTRUCTION:</span> Add inlets, then drag the 3D Gizmos to position sources on the organ surface.
            </p>
        </div>

        <!-- Section 3: Simulation -->
        <div class="panel-section">
            <div class="panel-header">03 // GROWTH ALGORITHM</div>
            <div class="control-group">
                <div class="label-row">
                    <span>TARGET DENSITY</span>
                    <div class="help-icon">?</div>
                    <div class="tooltip">Number of perfusion targets (capillary beds) the network attempts to reach. Higher = more fine branching.</div>
                    <span id="v-targets" class="value-display">400</span>
                </div>
                <input type="range" id="i-targets" min="100" max="1000" step="50" value="400">
            </div>
            <div class="control-group">
                <div class="label-row">
                    <span>ARTERIAL BUNDLING</span>
                    <div class="help-icon">?</div>
                    <div class="tooltip">Controls how strongly vessels prefer to merge. High values create thick main trunks; low values create a web-like diffuse network.</div>
                    <span id="v-bundle" class="value-display">3.0</span>
                </div>
                <input type="range" id="i-bundle" min="0" max="10.0" step="0.5" value="3.0">
            </div>
            
            <div class="control-group">
                <div class="label-row">
                    <span>FLOW VELOCITY</span>
                    <div class="help-icon">?</div>
                    <div class="tooltip">Global speed multiplier for the particle animation. Physics is based on vessel diameter.</div>
                    <span id="v-speed" class="value-display">0.02</span>
                </div>
                <input type="range" id="i-speed" min="0.001" max="0.1" step="0.001" value="0.02">
            </div>
            
            <div style="margin-top: 15px; display: flex; align-items: center; gap: 10px; font-size: 12px;">
                <input type="checkbox" id="c-flow" onchange="toggleFlow()" style="accent-color: var(--primary);">
                <label for="c-flow" style="color: var(--text-muted); cursor: pointer;">SHOW PARTICLES</label>
            </div>

            <button class="btn-tech" id="btn-grow" disabled onclick="run(growVessels)" style="margin-top: 15px; border-color: var(--primary); background: rgba(0,243,255,0.1);">INITIATE SIMULATION</button>
        </div>

        <!-- Section 4: Export -->
        <div class="panel-section">
            <div class="panel-header">04 // DATA EXPORT</div>
            <div class="btn-group">
                <button class="btn-tech" id="btn-exp-vessel" disabled onclick="exportData('vessels')">JSON GRAPH</button>
                <button class="btn-tech" id="btn-exp-obj" disabled onclick="exportData('obj')">OBJ MESH</button>
            </div>
        </div>
    </div>

    <footer>
        <div class="metric">NODES: <span id="s-voxels">0</span></div>
        <div class="metric">VESSELS: <span id="s-segs">0</span></div>
        <div class="metric">FLOW PARTICLES: <span id="s-parts" style="color:#0f0">0</span></div>
    </footer>
</div>

<div id="loading">
    <div style="font-size: 14px; letter-spacing: 3px; font-weight: bold; color: var(--primary);">COMPUTING VASCULAR PATHWAYS</div>
    <div class="loader-bar"></div>
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { TransformControls } from 'three/addons/controls/TransformControls.js';
import { STLLoader } from 'three/addons/loaders/STLLoader.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

// --- NOISE ---
class SimplexNoise {
    constructor() {
        this.p = new Uint8Array(256);
        for(let i=0; i<256; i++) this.p[i] = i;
        for(let i=0; i<256; i++) { let r = Math.floor(Math.random()*256); [this.p[i], this.p[r]] = [this.p[r], this.p[i]]; }
        this.perm = new Uint8Array(512);
        for(let i=0; i<512; i++) this.perm[i] = this.p[i & 255];
        this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
    }
    dot(g, x, y, z) { return g[0]*x + g[1]*y + g[2]*z; }
    noise(x, y, z) {
        const F3 = 1.0/3.0, s = (x+y+z)*F3, i = Math.floor(x+s), j = Math.floor(y+s), k = Math.floor(z+s), G3 = 1.0/6.0, t = (i+j+k)*G3;
        const x0 = x-(i-t), y0 = y-(j-t), z0 = z-(k-t);
        let i1, j1, k1, i2, j2, k2;
        if(x0>=y0) { if(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } else if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } }
        else { if(y0<z0){ i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } else if(x0<z0){ i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } }
        const gi0 = this.perm[(i&255)+this.perm[(j&255)+this.perm[k&255]]] % 12;
        let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
        return 32.0 * (t0 < 0 ? 0 : Math.pow(t0, 4) * this.dot(this.grad3[gi0], x0, y0, z0));
    }
}

// --- APP STATE ---
const state = { 
    nodes: [], inlets: [], targets: [], segments: [], 
    organMesh: null, linesMesh: null, pointsMesh: null, 
    inletCounter: 0,
    maxFlow: 1, // Store max flow for heatmap normalization
    leaves: new Set() // Set of node indices that are terminals
};
let scene, camera, renderer, composer, controls, transformControls;
const noise = new SimplexNoise();
let flowSystem = null;

function init() {
    // Scene Setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05070a); 
    
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(12, 8, 15);

    renderer = new THREE.WebGLRenderer({antialias:false, powerPreference: "high-performance", alpha: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ReinhardToneMapping;
    // Clear color alpha 0 to see CSS
    renderer.setClearColor(0x000000, 0); 
    document.body.appendChild(renderer.domElement);

    // --- BLOOM PIPELINE ---
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.1;
    bloomPass.strength = 1.2; 
    bloomPass.radius = 0.5;

    const outputPass = new OutputPass();
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);
    composer.addPass(outputPass);

    // --- CONTROLS ---
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    
    transformControls = new TransformControls(camera, renderer.domElement);
    transformControls.addEventListener('dragging-changed', (e) => controls.enabled = !e.value);
    scene.add(transformControls);

    // --- LIGHTING ---
    const ambient = new THREE.AmbientLight(0x404040);
    scene.add(ambient);
    const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x111111);
    gridHelper.position.y = -6;
    scene.add(gridHelper);

    // Bind UI (Added 'i-points')
    ['i-noise','i-points','i-targets','i-bundle','i-speed'].forEach(id => {
        const el = document.getElementById(id), val = document.getElementById(id.replace('i-','v-'));
        if(el && val) el.oninput = () => val.innerText = el.value;
    });

    // Resize
    window.addEventListener('resize', onResize);

    // Raycast Interaction (Fix: use recursive=true and check parents)
    const ray = new THREE.Raycaster(), mouse = new THREE.Vector2();
    renderer.domElement.addEventListener('pointerdown', (e) => {
        if(e.button !== 0 || e.target.closest('#ui-container')) return;
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        ray.setFromCamera(mouse, camera);
        
        // Fix: Check all inlet meshes recursively
        const inletMeshes = state.inlets.map(i => i.mesh);
        const hits = ray.intersectObjects(inletMeshes, true); // true = recursive (hits children/shells)
        
        if (hits.length > 0) {
            // Traverse up from hit object to find the inlet mesh
            let target = hits[0].object;
            while(target && !inletMeshes.includes(target)) {
                target = target.parent;
            }
            if(target) {
                selectInlet(state.inlets.find(i => i.mesh === target));
            }
        } else if (transformControls.object && !ray.intersectObject(transformControls.children[0], true).length) {
            selectInlet(null);
        }
    });

    // --- FLOW PARTICLE SYSTEM INIT ---
    flowSystem = new FlowParticleSystem();
    flowSystem.mesh.visible = false; 
    scene.add(flowSystem.mesh);

    animate();
    run(genVolume).then(() => addInlet());
}

function onResize() { 
    camera.aspect = window.innerWidth / window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

function animate() { 
    requestAnimationFrame(animate); 
    controls.update(); 
    if(flowSystem) flowSystem.update();
    composer.render(); 
}

// --- PARTICLE SYSTEM CLASS ---
class FlowParticleSystem {
    constructor() {
        this.maxParticles = 20000; // Increased buffer for denser tissue
        this.dummy = new THREE.Object3D();
        const geo = new THREE.SphereGeometry(1, 8, 8); 
        const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        this.mesh = new THREE.InstancedMesh(geo, mat, this.maxParticles);
        this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
        this.mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(this.maxParticles * 3), 3);
        this.mesh.frustumCulled = false;
        
        this.progress = new Float32Array(this.maxParticles).map(() => Math.random());
        
        // Color Cache
        this.cHigh = new THREE.Color(0xffffff); // White
        this.cMed = new THREE.Color(0xffaa00);  // Orange
        this.cLow = new THREE.Color(0xff0000);  // Deep Red
        this.tempCol = new THREE.Color();
    }

    reset() {
        this.mesh.count = 0;
        this.mesh.visible = false;
        // Reset progress randoms
        for(let i=0; i<this.maxParticles; i++) this.progress[i] = Math.random();
        const flowCheck = document.getElementById('c-flow');
        if(flowCheck) flowCheck.checked = false;
    }

    show() {
        // Just ensures internal state is ready if needed
    }

    update() {
        const visible = document.getElementById('c-flow').checked;
        this.mesh.visible = visible;
        if (!visible || !state.segments.length) return;

        const globalSpeedMult = parseFloat(document.getElementById('i-speed').value);

        const p0 = new THREE.Vector3();
        const p1 = new THREE.Vector3();
        const pos = new THREE.Vector3();
        
        const count = Math.min(state.segments.length, this.maxParticles);
        
        for (let i = 0; i < count; i++) {
            const seg = state.segments[i];
            
            // CFD Velocity approximation: v proportional to r^1.5
            const velocity = Math.pow(seg.r, 1.5) * 5.0; 
            
            // dt = velocity / length * multiplier
            const dt = (velocity / (seg.len + 0.0001)) * globalSpeedMult;
            
            // Update progress
            this.progress[i] = (this.progress[i] + dt) % 1.0;
            const t = this.progress[i];

            p0.copy(seg.p0);
            p1.copy(seg.p1);
            pos.lerpVectors(p0, p1, t);
            
            this.dummy.position.copy(pos);
            
            // --- LOGARITHMIC SCALE LOGIC ---
            let scale = 0.025 * (1 + Math.log(1 + seg.r * 5)); 
            
            // "Die" at terminal end
            if (seg.isTerminal) {
                scale *= (1.0 - Math.pow(t, 2)); 
            }
            this.dummy.scale.setScalar(scale);
            this.dummy.updateMatrix();
            this.mesh.setMatrixAt(i, this.dummy.matrix);

            // --- HEATMAP COLOR LOGIC ---
            const flowRatio = Math.min(1.0, seg.flow / (state.maxFlow || 1));
            
            if (flowRatio < 0.2) {
                this.tempCol.copy(this.cLow); 
            } else if (flowRatio < 0.6) {
                this.tempCol.lerpColors(this.cLow, this.cMed, (flowRatio - 0.2) * 2.5);
            } else {
                this.tempCol.lerpColors(this.cMed, this.cHigh, (flowRatio - 0.6) * 2.5);
            }
            
            this.mesh.setColorAt(i, this.tempCol);
        }

        this.mesh.count = count;
        this.mesh.instanceMatrix.needsUpdate = true;
        this.mesh.instanceColor.needsUpdate = true;
        
        const el = document.getElementById('s-parts');
        if(el && Math.random()>0.9) el.innerText = count;
    }
}

window.toggleFlow = () => {
    if(flowSystem) flowSystem.update();
};

// --- ASYNC RUNNER ---
window.run = async (fn) => {
    const loader = document.getElementById('loading');
    const status = document.getElementById('system-status');
    if(loader) loader.classList.add('active');
    if(status) { status.innerText = "PROCESSING"; status.style.color = "#ffaa00"; status.style.borderColor = "#ffaa00"; }
    
    await new Promise(r => setTimeout(r, 100)); // UI Paint
    try { await fn(); } catch(e) { console.error(e); alert("Operation failed: " + e.message); }
    
    if(loader) loader.classList.remove('active');
    if(status) { status.innerText = "SYSTEM READY"; status.style.color = "#00f3ff"; status.style.borderColor = "#00f3ff"; }
};

// --- INLET SYSTEM ---
window.addInlet = () => {
    if (state.inlets.length >= 4) return;
    const id = ++state.inletCounter;
    const geo = new THREE.SphereGeometry(0.4, 32, 32);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00f3ff });
    const mesh = new THREE.Mesh(geo, mat);
    const shell = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), new THREE.MeshBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.2, wireframe: true }));
    mesh.add(shell);
    mesh.position.set(-6, (state.inlets.length * 3) - 3, 0);
    scene.add(mesh);
    
    const inlet = { mesh, id }; 
    state.inlets.push(inlet);
    renderInletList(); 
    selectInlet(inlet);
};

function selectInlet(inlet) { 
    if (!inlet) { transformControls.detach(); } 
    else { transformControls.attach(inlet.mesh); }
    renderInletList();
}

window.removeInlet = (id) => {
    const idx = state.inlets.findIndex(i => i.id === id);
    if (idx !== -1) {
        if (transformControls.object === state.inlets[idx].mesh) transformControls.detach();
        scene.remove(state.inlets[idx].mesh); 
        state.inlets.splice(idx, 1);
        renderInletList();
    }
};

function renderInletList() {
    const list = document.getElementById('inlets-list'); if(!list) return; list.innerHTML = '';
    const btn = document.getElementById('btn-add-inlet'); if(btn) btn.disabled = state.inlets.length >= 4;
    
    state.inlets.forEach(inlet => {
        const isSelected = transformControls.object === inlet.mesh;
        const item = document.createElement('div'); 
        item.className = 'inlet-item' + (isSelected ? ' active' : '');
        item.innerHTML = `<span onclick="selectInletById(${inlet.id})">SOURCE_NODE_0${inlet.id}</span>
                          <span class="del" onclick="removeInlet(${inlet.id})">DEL</span>`;
        list.appendChild(item);
    });
}
window.selectInletById = (id) => selectInlet(state.inlets.find(i => i.id === id));

// --- MESH GENERATION ---
async function genVolume() {
    const nScale = parseFloat(document.getElementById('i-noise').value);
    const geo = new THREE.IcosahedronGeometry(5, 5);
    const pos = geo.attributes.position, v = new THREE.Vector3(), seed = Math.random()*100;
    
    for(let i=0; i<pos.count; i++){
        v.fromBufferAttribute(pos, i);
        const d = noise.noise(v.x*0.15+seed, v.y*0.15+seed, v.z*0.15+seed) * nScale;
        v.multiplyScalar(1 + d);
        pos.setXYZ(i, v.x, v.y, v.z);
    }
    geo.computeVertexNormals(); 
    geo.computeBoundingBox();
    setupVolume(geo);
}

window.handleFileUpload = (event) => {
    const file = event.target.files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        const loader = new STLLoader(); const geometry = loader.parse(e.target.result);
        geometry.computeBoundingBox(); geometry.center(); 
        const size = new THREE.Vector3(); geometry.boundingBox.getSize(size);
        const maxDim = Math.max(size.x, size.y, size.z);
        if(maxDim > 10) geometry.scale(10/maxDim, 10/maxDim, 10/maxDim);
        run(() => setupVolume(geometry));
    };
    reader.readAsArrayBuffer(file);
};

function setupVolume(geo) {
    // Reset Data State
    state.segments = [];
    state.leaves.clear();
    state.maxFlow = 1;
    if(flowSystem) flowSystem.reset();

    // Reset Meshes
    if(state.organMesh) { scene.remove(state.organMesh); state.organMesh.geometry.dispose(); }
    if(state.linesMesh) { scene.remove(state.linesMesh); state.linesMesh.geometry.dispose(); }
    if(state.pointsMesh) { scene.remove(state.pointsMesh); state.pointsMesh.geometry.dispose(); }
    
    const wireMat = new THREE.MeshBasicMaterial({color: 0x00f3ff, wireframe: true, transparent: true, opacity: 0.05 });
    state.organMesh = new THREE.Mesh(geo, wireMat);
    scene.add(state.organMesh);

    const box = geo.boundingBox, size = new THREE.Vector3(); box.getSize(size);
    const ray = new THREE.Raycaster(), rayDir = new THREE.Vector3(1,0,0), meshD = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({side:THREE.DoubleSide}));
    meshD.updateMatrixWorld();
    
    // Use user-defined point count
    const targetPoints = parseInt(document.getElementById('i-points').value) || 3000;
    
    const pts = [];
    let attempts = 0;
    // Safety break loop
    const maxAttempts = targetPoints * 10; 
    
    while(pts.length < targetPoints && attempts < maxAttempts) {
        attempts++;
        const p = new THREE.Vector3(
            box.min.x + Math.random()*size.x, 
            box.min.y + Math.random()*size.y, 
            box.min.z + Math.random()*size.z
        );
        ray.set(p, rayDir); 
        if(ray.intersectObject(meshD).length % 2 === 1) {
            pts.push({ x:p.x, y:p.y, z:p.z, ox:p.x, oy:p.y, oz:p.z, id:pts.length, neighbors: [] });
        }
    }
    state.nodes = pts;

    const pGeo = new THREE.BufferGeometry(), pPos = new Float32Array(pts.length * 3);
    for(let i=0; i<pts.length; i++) { pPos[i*3]=pts[i].x; pPos[i*3+1]=pts[i].y; pPos[i*3+2]=pts[i].z; }
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    state.pointsMesh = new THREE.Points(pGeo, new THREE.PointsMaterial({color: 0x445566, size: 0.05, transparent: true, opacity: 0.6}));
    state.pointsMesh.visible = document.getElementById('c-pts').checked;
    
    // Prevent points from disappearing on zoom/pan
    state.pointsMesh.frustumCulled = false;
    
    scene.add(state.pointsMesh);

    // Calculate connection distance based on density approx
    // V ~ L^3, N points -> dist ~ L / N^(1/3)
    // Roughly if 3000 -> 1.25. If 6000 -> smaller.
    // Let's adapt connDist slightly based on points count to ensure connectivity
    // 3000 -> 1.25. 1000 -> 1.8. 
    const densityFactor = Math.pow(3000 / targetPoints, 0.33); 
    const connDist = 1.25 * densityFactor;
    const connDistSq = connDist**2;
    
    for(let i=0; i<pts.length; i++) {
        for(let j=i+1; j<pts.length; j++) {
            const d2 = (pts[i].x-pts[j].x)**2 + (pts[i].y-pts[j].y)**2 + (pts[i].z-pts[j].z)**2;
            if(d2 < connDistSq) {
                const d = Math.sqrt(d2);
                pts[i].neighbors.push({ to: j, dist: d, cond: 1.0, flow: 0 });
                pts[j].neighbors.push({ to: i, dist: d, cond: 1.0, flow: 0 });
            }
        }
    }
    document.getElementById('s-voxels').innerText = pts.length;
    document.getElementById('btn-grow').disabled = false;
}

window.togglePoints = () => { if(state.pointsMesh) state.pointsMesh.visible = document.getElementById('c-pts').checked; }

// --- ALGORITHM: CONSTRUCTIVE OPTIMIZATION ---
async function growVessels() {
    controls.autoRotate = false; transformControls.detach();
    if(state.linesMesh) { scene.remove(state.linesMesh); state.linesMesh.geometry.dispose(); }
    if (state.inlets.length === 0) { alert("ERROR: NO INLET SOURCES DEFINED"); return; }
    
    // STOP particles
    if(flowSystem) flowSystem.reset();

    // Reset Physics
    const posAttr = state.pointsMesh.geometry.attributes.position;
    for(let i=0; i<state.nodes.length; i++) {
        state.nodes[i].x = state.nodes[i].ox; 
        state.nodes[i].y = state.nodes[i].oy; 
        state.nodes[i].z = state.nodes[i].oz;
        state.nodes[i].neighbors.forEach(e => { e.cond = 1.0; e.flow = 0; });
        posAttr.setXYZ(i, state.nodes[i].x, state.nodes[i].y, state.nodes[i].z);
    }
    posAttr.needsUpdate = true;

    // Map Inlets
    const sourceMap = state.inlets.map(inlet => {
        let minDist = Infinity, nearestIdx = 0;
        for(let i=0; i<state.nodes.length; i++){
            const d2 = inlet.mesh.position.distanceToSquared(state.nodes[i]);
            if(d2 < minDist){ minDist = d2; nearestIdx = i; }
        }
        return { inlet, nodeIdx: nearestIdx };
    });
    const sourceIndices = sourceMap.map(m => m.nodeIdx);

    // Targets
    const numTargets = parseInt(document.getElementById('i-targets').value);
    const indices = Array.from({length: state.nodes.length}, (_, k) => k);
    for(let i=indices.length-1; i>0; i--) { const j = Math.floor(Math.random()*(i+1)); [indices[i], indices[j]] = [indices[j], indices[i]]; }
    state.targets = indices.slice(0, numTargets).filter(id => !sourceIndices.includes(id));

    const iterations = 8;
    const bundleFactor = parseFloat(document.getElementById('i-bundle').value);

    // Setup Geometry
    state.linesMesh = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2, transparent: true, blending: THREE.AdditiveBlending }));
    
    // Prevent frustum culling to fix disappearing lines
    state.linesMesh.frustumCulled = false;
    
    scene.add(state.linesMesh);
    
    // ITERATIVE GROWTH (The "Simulator")
    for(let iter=0; iter<iterations; iter++) {
        // UI Yield to allow animation frame
        await new Promise(r => setTimeout(r, 10)); 

        // Dijkstra
        const dists = new Float32Array(state.nodes.length).fill(Infinity);
        const parents = new Int32Array(state.nodes.length).fill(-1);
        const visited = new Uint8Array(state.nodes.length).fill(0);
        let active = new Set();
        sourceIndices.forEach(idx => { dists[idx] = 0; active.add(idx); });

        while(active.size > 0) {
            let u = -1, minD = Infinity;
            for(let id of active) { if(dists[id] < minD) { minD = dists[id]; u = id; } }
            if(u === -1) break;
            active.delete(u); visited[u] = 1;

            const n = state.nodes[u];
            for(let edge of n.neighbors) {
                if(visited[edge.to]) continue;
                const cost = edge.dist / (1.0 + bundleFactor * edge.cond);
                const alt = dists[u] + cost;
                if(alt < dists[edge.to]) {
                    dists[edge.to] = alt;
                    parents[edge.to] = u;
                    active.add(edge.to);
                }
            }
        }

        // Trace & Flow
        for(let n of state.nodes) n.neighbors.forEach(e => e.flow = 0);
        for(let t of state.targets) {
            let curr = t;
            while(!sourceIndices.includes(curr) && curr !== -1) {
                const p = parents[curr];
                if(p === -1) break;
                state.nodes[p].neighbors.find(e => e.to === curr).flow += 1;
                state.nodes[curr].neighbors.find(e => e.to === p).flow += 1;
                curr = p;
            }
        }

        // Update Conductivity
        if(iter < iterations-1) {
            for(let n of state.nodes) n.neighbors.forEach(e => e.cond += e.flow);
        }
        
        // Pass 'dists' to enable directional sorting
        updateVisualization(sourceMap, dists);
    }

    // Enable particles checkbox
    document.getElementById('c-flow').disabled = false;
    document.getElementById('c-flow').checked = true; // Auto-enable on finish
    flowSystem.show();

    ['btn-exp-vessel','btn-exp-obj'].forEach(id => document.getElementById(id).disabled = false);
}

function updateVisualization(sourceMap, dists) {
    state.segments = [];
    state.leaves.clear(); // Reset leaf tracking
    let maxFlow = 0;
    
    // RESTORED OLD GENERATOR (Iterate all Edges)
    // PLUS DIRECTIONAL LOGIC (Using dists)
    
    // First pass: identify flows and build segments
    for(let i=0; i<state.nodes.length; i++) {
        for(let edge of state.nodes[i].neighbors) {
            // "edge.to > i" prevents duplicates (processing A-B and B-A)
            if(edge.to > i && edge.flow > 0) {
                maxFlow = Math.max(maxFlow, edge.flow);
                
                const nA = state.nodes[i];
                const nB = state.nodes[edge.to];
                
                // Directional Sort: Flow goes from Low Distance to High Distance
                let pStart, pEnd, pEndIdx;
                if(dists && dists[i] < dists[edge.to]) {
                    pStart = nA; pEnd = nB; pEndIdx = edge.to;
                } else {
                    pStart = nB; pEnd = nA; pEndIdx = i;
                }
                
                // Calc length for CFD physics
                const dx = pStart.x - pEnd.x;
                const dy = pStart.y - pEnd.y;
                const dz = pStart.z - pEnd.z;
                const len = Math.sqrt(dx*dx + dy*dy + dz*dz);

                state.segments.push({ p0: pStart, p1: pEnd, flow: edge.flow, endIdx: pEndIdx, len: len });
            }
        }
    }
    
    // Inlet Connectors
    sourceMap.forEach(m => {
        const n = state.nodes[m.nodeIdx];
        let sumF = 0; n.neighbors.forEach(e => sumF += e.flow);
        if(sumF > 0) {
            maxFlow = Math.max(maxFlow, sumF);
            // Inlets are always the start
            const len = m.inlet.mesh.position.distanceTo(n);
            state.segments.push({ p0: m.inlet.mesh.position, p1: n, flow: sumF, endIdx: m.nodeIdx, len: len });
        }
    });

    state.maxFlow = maxFlow;

    // Second pass: Determine "Terminal" segments (Particles die here)
    // Applying heuristic: Low flow = capillary/terminal
    state.segments.forEach(s => {
       s.isTerminal = (s.flow <= 1); // Simplest logic for visuals
    });

    const pos = [], cols = [];
    const cLow = new THREE.Color(0x550000);
    const cMid = new THREE.Color(0xff0000);
    const cHigh = new THREE.Color(0xffaa00);
    const cMax = new THREE.Color(0xffffff);

    for(let s of state.segments) {
        pos.push(s.p0.x, s.p0.y, s.p0.z, s.p1.x, s.p1.y, s.p1.z);
        s.r = Math.sqrt(s.flow) * 0.06;
        
        const t = Math.pow(s.flow / (maxFlow || 1), 0.4);
        let c = new THREE.Color();
        if(t < 0.3) c.lerpColors(cLow, cMid, t*3.3);
        else if(t < 0.7) c.lerpColors(cMid, cHigh, (t-0.3)*2.5);
        else c.lerpColors(cHigh, cMax, (t-0.7)*3.3);
        
        cols.push(c.r, c.g, c.b, c.r, c.g, c.b);
    }
    
    const geo = state.linesMesh.geometry;
    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
    geo.setDrawRange(0, pos.length/3);
    
    // Explicitly update bounds to be sure (though frustumCulled=false makes it redundant, it's good practice for raycasting if added later)
    geo.computeBoundingSphere();
    
    document.getElementById('s-segs').innerText = state.segments.length;
}

window.exportData = (type) => {
    let content = "", mime = "application/json", ext = "json";
    if(type === 'vessels') {
        content = JSON.stringify(state.segments.map(s => ({ 
            p1: [s.p0.x, s.p0.y, s.p0.z], 
            p2: [s.p1.x, s.p1.y, s.p1.z], 
            flow: s.flow 
        })));
    } else {
        content = "# Vascular Tree OBJ\n";
        let vIdx = 1;
        state.segments.forEach(s => {
            content += `v ${s.p0.x} ${s.p0.y} ${s.p0.z}\n`;
            content += `v ${s.p1.x} ${s.p1.y} ${s.p1.z}\n`;
            content += `l ${vIdx} ${vIdx+1}\n`;
            vIdx += 2;
        });
        mime = "text/plain"; ext = "obj";
    }
    const blob = new Blob([content], {type: mime});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = `vascular_data.${ext}`;
    a.click();
};

window.genVolume = genVolume;
window.growVessels = growVessels;

init();
</script>
</body>
</html>