<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bio-Digital Vascular Engine // V6.9</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Rajdhani:wght@400;600;700&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-dark: #05070a;
            --panel-bg: rgba(10, 15, 20, 0.85);
            --panel-border: rgba(0, 243, 255, 0.2);
            --primary: #00f3ff;
            --primary-dim: rgba(0, 243, 255, 0.1);
            --secondary: #ff2a2a;
            --text-main: #e0f0ff;
            --text-muted: #64748b;
            --grid-color: rgba(255, 255, 255, 0.03);
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-dark);
            background: radial-gradient(circle at center, #1b2838 0%, #0b1016 50%, #000000 100%);
            font-family: 'Rajdhani', sans-serif;
            color: var(--text-main);
            user-select: none;
        }

        body::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%);
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.3;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: grid;
            grid-template-rows: 60px 1fr 40px;
            grid-template-columns: 360px 1fr;
            grid-template-areas: "header header" "sidebar viewport" "footer footer";
            z-index: 10;
        }

        header {
            grid-area: header;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 25px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0) 100%);
            border-bottom: 1px solid var(--panel-border);
            pointer-events: auto;
        }

        .app-title {
            font-size: 24px;
            font-weight: 700;
            letter-spacing: 2px;
            text-shadow: 0 0 10px var(--primary);
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-badge {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            background: var(--primary-dim);
            color: var(--primary);
            padding: 4px 8px;
            border: 1px solid var(--primary);
            border-radius: 2px;
        }

        #sidebar {
            grid-area: sidebar;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            border-right: 1px solid var(--panel-border);
            padding: 20px;
            overflow-y: auto;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 25px;
            box-shadow: 10px 0 30px rgba(0, 0, 0, 0.5);
        }

        .panel-section {
            position: relative;
        }

        .panel-header {
            font-size: 14px;
            color: var(--primary);
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }

        .panel-header::after {
            content: '';
            height: 1px;
            flex-grow: 1;
            background: linear-gradient(90deg, var(--primary) 0%, transparent 100%);
            opacity: 0.5;
        }

        #doc-content {
            font-size: 11px;
            line-height: 1.5;
            color: var(--text-muted);
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            display: none;
        }

        #doc-content.open {
            display: block;
        }

        #doc-content strong {
            color: var(--text-main);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .label-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            position: relative;
        }

        .value-display {
            font-family: 'JetBrains Mono', monospace;
            color: var(--primary);
        }

        .help-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            font-size: 9px;
            cursor: help;
            margin-left: 6px;
            transition: 0.2s;
        }

        .help-icon:hover {
            background: var(--primary);
            color: #000;
        }

        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 0;
            width: 100%;
            background: #0f161d;
            border: 1px solid var(--primary);
            color: #e0f0ff;
            padding: 8px;
            border-radius: 4px;
            font-size: 10px;
            line-height: 1.4;
            font-weight: normal;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transform: translateY(5px);
            transition: all 0.2s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.8);
        }

        .help-icon:hover+.tooltip,
        .label-row:hover .tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]:focus {
            outline: none;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 6px;
            background: var(--primary);
            margin-top: -6px;
            box-shadow: 0 0 10px var(--primary);
            cursor: pointer;
            border-radius: 1px;
            transition: 0.2s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scaleY(1.2);
            background: #fff;
        }

        select {
            width: 100%;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--panel-border);
            color: var(--text-main);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            margin-top: 5px;
            cursor: pointer;
            outline: none;
            border-radius: 4px;
        }

        select:hover {
            border-color: var(--primary);
            background: rgba(0, 243, 255, 0.05);
        }

        option {
            background: #0b1016;
            color: #fff;
        }

        .btn-tech {
            width: 100%;
            padding: 12px;
            background: linear-gradient(90deg, rgba(0, 243, 255, 0.05) 0%, transparent 100%);
            border: 1px solid var(--panel-border);
            color: var(--primary);
            font-family: 'Rajdhani', sans-serif;
            font-weight: 700;
            font-size: 14px;
            letter-spacing: 1px;
            text-transform: uppercase;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }

        .btn-tech::before {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 2px;
            background: var(--primary);
            transform: scaleX(0);
            transform-origin: left;
            transition: 0.3s;
        }

        .btn-tech:hover:not(:disabled) {
            background: rgba(0, 243, 255, 0.15);
            box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
        }

        .btn-tech:hover::before {
            transform: scaleX(1);
        }

        .btn-tech:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            filter: grayscale(1);
        }

        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 8px;
        }

        .inlet-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.05);
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: 0.2s;
        }

        .inlet-item:hover {
            border-color: var(--primary);
        }

        .inlet-item.active {
            border-color: var(--primary);
            background: rgba(0, 243, 255, 0.05);
        }

        .inlet-item .del {
            color: var(--secondary);
            font-weight: bold;
            padding: 4px;
        }

        .inlet-item .del:hover {
            color: #fff;
        }

        footer {
            grid-area: footer;
            background: var(--panel-bg);
            border-top: 1px solid var(--panel-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--text-muted);
            pointer-events: auto;
        }

        .metric {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .metric span {
            color: var(--primary);
        }

        #loading {
            position: absolute;
            inset: 0;
            background: #000;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
            pointer-events: none;
            opacity: 0;
        }

        #loading.active {
            opacity: 1;
            pointer-events: auto;
        }

        .loader-bar {
            width: 200px;
            height: 2px;
            background: #333;
            margin-top: 20px;
            position: relative;
            overflow: hidden;
        }

        .loader-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: 50%;
            background: var(--primary);
            animation: load 1s infinite linear;
        }

        @keyframes load {
            0% {
                left: -50%;
            }

            100% {
                left: 100%;
            }
        }

        canvas {
            outline: none;
        }
    </style>

    <script type="importmap">
        { "imports": { 
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", 
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" 
        } }
    </script>
</head>

<body>

    <div id="ui-container">
        <header>
            <div class="app-title">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="#00f3ff" stroke-width="2">
                    <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path>
                </svg>
                BIO-DIGITAL VASCULAR ENGINE
            </div>
            <div class="status-badge" id="system-status">SYSTEM READY</div>
        </header>

        <div id="sidebar">
            <div class="panel-section">
                <div class="panel-header" onclick="document.getElementById('doc-content').classList.toggle('open')">00
                    // SYSTEM ARCHITECTURE <span style="font-size:10px; opacity:0.5; margin-left:auto">â–¼</span></div>
                <div id="doc-content">
                    <strong>Spline smoothing:</strong> Uses Catmull-Rom interpolation with junction-awareness to avoid
                    gaps at bifurcations.
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-header">01 // VOLUME SYNTHESIS</div>
                <div class="control-group">
                    <div class="label-row"><span>ORGAN PRESET</span></div>
                    <select id="s-organ">
                        <option value="SPHERE">Spherical (Default)</option>
                        <option value="HEART">Myocardium (Heart)</option>
                        <option value="KIDNEY">Kidney (Renal)</option>
                        <option value="LIVER">Liver (Hepatic)</option>
                        <option value="MUSCLE">Muscle (Fusiform)</option>
                        <option value="SPLEEN">Spleen (Ellipsoid)</option>
                    </select>
                </div>
                <div class="control-group">
                    <div class="label-row"><span>IRREGULARITY NOISE</span><span id="v-noise"
                            class="value-display">0.7</span></div>
                    <input type="range" id="i-noise" min="0" max="1.5" step="0.1" value="0.7">
                </div>
                <div class="control-group">
                    <div class="label-row"><span>TISSUE RESOLUTION</span><span id="v-points"
                            class="value-display">3000</span></div>
                    <input type="range" id="i-points" min="1000" max="10000" step="500" value="3000">
                </div>
                <div class="btn-group">
                    <button class="btn-tech" onclick="window.run(genVolume)">GENERATE VOLUME</button>
                    <button class="btn-tech" onclick="document.getElementById('file-input').click()">UPLOAD STL</button>
                </div>
                <input type="file" id="file-input" style="display:none" accept=".stl"
                    onchange="window.handleFileUpload(event)">
                <div style="margin-top: 15px; display: flex; flex-direction: column; gap: 8px;">
                    <div style="display: flex; align-items: center; gap: 10px; font-size: 12px;">
                        <input type="checkbox" id="c-pts" checked onchange="window.togglePoints()"
                            style="accent-color: var(--primary);">
                        <label for="c-pts" style="color: var(--text-muted); cursor: pointer;">SHOW TISSUE GRID</label>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; font-size: 12px;">
                        <input type="checkbox" id="c-organ" checked onchange="window.toggleOrgan()"
                            style="accent-color: var(--primary);">
                        <label for="c-organ" style="color: var(--text-muted); cursor: pointer;">SHOW ORGAN SHELL</label>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-header">02 // PERFUSION SOURCES</div>
                <div id="inlets-list"></div>
                <div class="control-group">
                    <button class="btn-tech" id="btn-add-inlet" onclick="window.addInlet()">+ ADD INLET SOURCE</button>
                    <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px; font-size: 12px;">
                        <input type="checkbox" id="c-inlets" checked onchange="window.toggleInlets()"
                            style="accent-color: var(--primary);">
                        <label for="c-inlets" style="color: var(--text-muted); cursor: pointer;">SHOW SOURCES</label>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-header">03 // GROWTH ALGORITHM</div>
                <div class="control-group">
                    <div class="label-row"><span>TARGET DENSITY</span><span id="v-targets"
                            class="value-display">400</span></div>
                    <input type="range" id="i-targets" min="100" max="1000" step="50" value="400">
                </div>
                <div class="control-group">
                    <div class="label-row"><span>ARTERIAL BUNDLING</span><span id="v-bundle"
                            class="value-display">3.0</span></div>
                    <input type="range" id="i-bundle" min="0" max="10.0" step="0.5" value="3.0">
                </div>
                <div class="control-group">
                    <div class="label-row"><span>FLOW VELOCITY</span><span id="v-speed"
                            class="value-display">0.02</span></div>
                    <input type="range" id="i-speed" min="0.001" max="0.1" step="0.001" value="0.02">
                </div>
                <div class="control-group">
                    <div class="label-row">
                        <span>VELOCITY PROFILE</span>
                        <span id="v-profile" class="value-display">-1.0</span>
                    </div>
                    <input type="range" id="i-profile" min="-2.0" max="3.0" step="0.5" value="-1.0"
                        oninput="document.getElementById('v-profile').innerText = this.value">
                </div>

                <div
                    style="background: rgba(255,255,255,0.03); padding: 10px; border-radius: 4px; margin-top:10px; margin-bottom: 10px;">
                    <div style="font-size: 10px; color: var(--primary); font-weight: bold; margin-bottom: 8px;">GRAVITY
                        PHYSICS</div>
                    <div class="control-group" style="margin-bottom:8px">
                        <div class="label-row"><span>INFLUENCE</span><span id="v-g-str" class="value-display">0.0</span>
                        </div>
                        <input type="range" id="i-g-str" min="0" max="5.0" step="0.1" value="0.0">
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px; font-size: 12px; margin-top: 5px;">
                        <input type="checkbox" id="c-gravity" checked onchange="window.toggleGravityGizmo()"
                            style="accent-color: var(--primary);">
                        <label for="c-gravity" style="color: var(--text-muted); cursor: pointer;">SHOW DIRECTION</label>
                    </div>
                </div>

                <div style="margin-top: 15px; display: flex; align-items: center; gap: 10px; font-size: 12px;">
                    <input type="checkbox" id="c-flow" onchange="window.toggleFlow()"
                        style="accent-color: var(--primary);">
                    <label for="c-flow" style="color: var(--text-muted); cursor: pointer;">SHOW PARTICLES</label>
                </div>
                <div class="control-group" style="margin-top:10px">
                    <div class="label-row"><span>ANIMATION SPEED</span><span id="v-anim-speed"
                            class="value-display">60</span></div>
                    <input type="range" id="i-anim-speed" min="10" max="240" step="1" value="60">
                </div>
                <button class="btn-tech" id="btn-grow" disabled onclick="window.run(window.growVessels)"
                    style="margin-top: 15px; border-color: var(--primary); background: rgba(0,243,255,0.1);">INITIATE
                    SIMULATION</button>
                <button class="btn-tech" id="btn-animate" disabled onclick="window.animateGrowth()"
                    style="margin-top: 8px; border-color: var(--primary); background: rgba(0,0,0,0.12);">ANIMATE
                    GROWTH</button>
            </div>

            <div class="panel-section">
                <div class="panel-header">04 // DATA EXPORT</div>
                <div class="btn-group">
                    <button class="btn-tech" id="btn-exp-vessel" disabled onclick="window.exportData('vessels')">JSON
                        GRAPH</button>
                    <button class="btn-tech" id="btn-exp-obj" disabled onclick="exportData('obj')">OBJ LINES</button>
                </div>
                <div style="background: rgba(255,255,255,0.03); padding: 10px; border-radius: 4px; margin-top:15px;">
                    <div style="font-size: 10px; color: var(--primary); font-weight: bold; margin-bottom: 8px;">SDF MESH
                        BAKING</div>
                    <div class="control-group" style="margin-bottom:8px">
                        <div class="label-row"><span>SDF RESOLUTION</span><span id="v-sdf-res"
                                class="value-display">64</span></div>
                        <input type="range" id="i-sdf-res" min="32" max="512" step="32" value="64"
                            oninput="document.getElementById('v-sdf-res').innerText = this.value">
                    </div>
                    <div class="btn-group">
                        <button class="btn-tech" id="btn-bake-mesh" disabled
                            onclick="window.run(window.bakeSdfMesh)">BAKE MESH</button>
                        <button class="btn-tech" id="btn-exp-baked" disabled onclick="window.exportBakedMesh()">EXPORT
                            OBJ</button>
                    </div>
                    <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px; font-size: 12px;">
                        <input type="checkbox" id="c-baked" onchange="window.toggleBakedMesh()"
                            style="accent-color: var(--primary);">
                        <label for="c-baked" style="color: var(--text-muted); cursor: pointer;">SHOW BAKED MESH</label>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-header">05 // RENDERING</div>
                <div class="control-group">
                    <div class="label-row">
                        <span>BLOOM INTENSITY</span>
                        <span id="v-bloom" class="value-display">0.80</span>
                    </div>
                    <!-- Reduced max value and high precision step for better control -->
                    <input type="range" id="i-bloom" min="0" max="2.0" step="0.01" value="0.80"
                        oninput="window.updateBloom()">
                </div>
                <div class="control-group">
                    <div class="label-row"><span>COLORMAP</span></div>
                    <select id="s-colormap" onchange="window.updateColorMap()">
                        <option value="INFERNO">INFERNO (Thermal)</option>
                        <option value="PLASMA">PLASMA (High Contrast)</option>
                        <option value="VIRIDIS">VIRIDIS (Scientific)</option>
                        <option value="ICE">ICE (Cold)</option>
                        <option value="BLOOD">BLOOD (Biological)</option>
                    </select>
                </div>
                <div class="control-group">
                    <div class="label-row"><span>PATH STYLE</span></div>
                    <select id="s-pathstyle" onchange="window.updatePathStyle()">
                        <option value="STRAIGHT">STRAIGHT (VOXEL)</option>
                        <option value="SMOOTH">SMOOTH (SPLINE)</option>
                    </select>
                </div>
                <div class="control-group">
                    <div class="label-row">
                        <span>VESSEL RADIUS</span>
                        <span id="v-vesselradius" class="value-display">0.50</span>
                    </div>
                    <input type="range" id="i-vesselradius" min="0.1" max="2.0" step="0.05" value="0.50"
                        oninput="window.updateVesselRadius()">
                </div>
                <div class="control-group">
                    <div class="label-row"><span>VESSEL GEOMETRY</span></div>
                    <select id="s-vesselgeo" onchange="window.updateVesselGeometry()">
                        <option value="CAPSULE">CAPSULE (Rounded)</option>
                        <option value="TUBE">TUBE (Closed Ends)</option>
                    </select>
                </div>
                <div style="margin-top: 10px; display: flex; align-items: center; gap: 10px; font-size: 12px;">
                    <input type="checkbox" id="c-bloom" checked onchange="window.toggleBloom()"
                        style="accent-color: var(--primary);">
                    <label for="c-bloom" style="color: var(--text-muted); cursor: pointer;">ENABLE BLOOM</label>
                </div>
            </div>
        </div>

        <footer>
            <div class="metric">NODES: <span id="s-voxels">0</span></div>
            <div class="metric">VESSELS: <span id="s-segs">0</span></div>
            <div class="metric">FLOW PARTICLES: <span id="s-parts" style="color:#0f0">0</span></div>
        </footer>
    </div>

    <div id="loading">
        <div style="font-size: 14px; letter-spacing: 3px; font-weight: bold; color: var(--primary);">COMPUTING VASCULAR
            PATHWAYS</div>
        <div class="loader-bar"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- CONSTANTS ---
        const COLOR_MAPS = {
            'INFERNO': [new THREE.Color(0x661100), new THREE.Color(0xff4400), new THREE.Color(0xffaa00), new THREE.Color(0xffff80), new THREE.Color(0xffffff)],
            'PLASMA': [new THREE.Color(0x440055), new THREE.Color(0xaa2288), new THREE.Color(0xcc6644), new THREE.Color(0xfebc2b), new THREE.Color(0xf0f921)],
            'VIRIDIS': [new THREE.Color(0x440154), new THREE.Color(0x31688e), new THREE.Color(0x35b779), new THREE.Color(0xaddc30), new THREE.Color(0xfde725)],
            'ICE': [new THREE.Color(0x002266), new THREE.Color(0x0066cc), new THREE.Color(0x00ccff), new THREE.Color(0x88eeff), new THREE.Color(0xffffff)],
            'BLOOD': [new THREE.Color(0x440000), new THREE.Color(0x990000), new THREE.Color(0xff0000), new THREE.Color(0xff6666), new THREE.Color(0xffaaaa)]
        };

        // --- APP STATE ---
        const state = {
            nodes: [], inlets: [], targets: [], segments: [],
            organMesh: null, linesMesh: null, pointsMesh: null,
            inletCounter: 0,
            maxFlow: 1,
            leaves: new Set(),
            currentColorMap: 'INFERNO',
            currentPathStyle: 'STRAIGHT',
            lastParents: null,
            lastDists: null,
            lastSourceMap: null
        };
        let scene, camera, renderer, composer, controls, transformControls;
        let bloomPass;
        let flowSystem = null;
        let gravityGizmo = null;

        // --- NOISE ---
        class SimplexNoise {
            constructor() {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 0; i < 256; i++) { let r = Math.floor(Math.random() * 256);[this.p[i], this.p[r]] = [this.p[r], this.p[i]]; }
                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
                this.grad3 = [[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0], [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1], [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]];
            }
            dot(g, x, y, z) { return g[0] * x + g[1] * y + g[2] * z; }
            noise(x, y, z) {
                const F3 = 1.0 / 3.0, s = (x + y + z) * F3, i = Math.floor(x + s), j = Math.floor(y + s), k = Math.floor(z + s), G3 = 1.0 / 6.0, t = (i + j + k) * G3;
                const x0 = x - (i - t), y0 = y - (j - t), z0 = z - (k - t);
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) { if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } }
                else { if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } }
                const gi0 = this.perm[(i & 255) + this.perm[(j & 255) + this.perm[k & 255]]] % 12;
                let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                return 32.0 * (t0 < 0 ? 0 : Math.pow(t0, 4) * this.dot(this.grad3[gi0], x0, y0, z0));
            }
        }
        const noise = new SimplexNoise();

        // --- EXPOSE run TO GLOBAL ---
        window.run = async (fn) => {
            const l = document.getElementById('loading'); if (l) l.classList.add('active');
            const statusBadge = document.getElementById('system-status');
            if (statusBadge) { statusBadge.innerText = "PROCESSING"; statusBadge.style.color = "#ffaa00"; statusBadge.style.borderColor = "#ffaa00"; }

            await new Promise(r => setTimeout(r, 100));
            try { await fn(); } catch (e) { console.error(e); }

            if (l) l.classList.remove('active');
            if (statusBadge) { statusBadge.innerText = "SYSTEM READY"; statusBadge.style.color = "#00f3ff"; statusBadge.style.borderColor = "#00f3ff"; }
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = null;

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 8, 15);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.setClearColor(0x000000, 0);
            document.body.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.05;
            bloomPass.strength = 0.8;
            bloomPass.radius = 0.5;

            const outputPass = new OutputPass();
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);
            composer.addPass(outputPass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            transformControls = new TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (e) => controls.enabled = !e.value);
            scene.add(transformControls);

            const ambient = new THREE.AmbientLight(0x404040);
            scene.add(ambient);
            const gridHelper = new THREE.GridHelper(50, 50, 0x333333, 0x111111);
            gridHelper.position.y = -6;
            scene.add(gridHelper);

            gravityGizmo = new THREE.Group();
            gravityGizmo.position.set(8, 5, 0);
            const gizmoMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, depthTest: false, transparent: true, opacity: 0.9 });
            const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2, 8), gizmoMat);
            shaft.position.y = -1;
            const head = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 16), gizmoMat);
            head.position.y = -2.25; head.rotation.x = Math.PI;
            gravityGizmo.add(shaft, head);
            const hitMesh = new THREE.Mesh(new THREE.SphereGeometry(1.5, 8, 8), new THREE.MeshBasicMaterial({ visible: false }));
            hitMesh.position.y = -1;
            gravityGizmo.add(hitMesh);
            scene.add(gravityGizmo);

            ['i-noise', 'i-points', 'i-targets', 'i-bundle', 'i-speed', 'i-g-str', 'i-anim-speed'].forEach(id => {
                const el = document.getElementById(id), val = document.getElementById(id.replace('i-', 'v-'));
                if (el && val) el.oninput = () => val.innerText = el.value;
            });

            window.addEventListener('resize', onResize);

            const ray = new THREE.Raycaster(), mouse = new THREE.Vector2();
            renderer.domElement.addEventListener('pointerdown', (e) => {
                if (e.button !== 0 || e.target.closest('#ui-container')) return;
                const rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                ray.setFromCamera(mouse, camera);

                const inletMeshes = state.inlets.map(i => i.mesh);
                let hits = ray.intersectObjects(inletMeshes, true);
                if (hits.length > 0) {
                    let target = hits[0].object;
                    while (target && !inletMeshes.includes(target)) target = target.parent;
                    if (target && target.visible) { selectInlet(state.inlets.find(i => i.mesh === target)); return; }
                }
                if (document.getElementById('c-gravity').checked) {
                    hits = ray.intersectObject(gravityGizmo, true);
                    if (hits.length > 0) { selectGravityGizmo(); return; }
                }
                if (transformControls.object && !ray.intersectObject(transformControls.children[0], true).length) selectInlet(null);
            });

            flowSystem = new FlowParticleSystem();
            flowSystem.mesh.visible = false;
            scene.add(flowSystem.mesh);

            vesselSystem = new VesselMeshSystem();
            scene.add(vesselSystem.mesh);

            animate();
            window.run(genVolume).then(() => window.addInlet());
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() { requestAnimationFrame(animate); controls.update(); if (flowSystem) flowSystem.update(); composer.render(); }

        // --- COLOR & UI ---
        function getGradientColor(t, targetColor) {
            const palette = COLOR_MAPS[state.currentColorMap];
            if (t <= 0) return targetColor.copy(palette[0]);
            if (t >= 1) return targetColor.copy(palette[palette.length - 1]);
            const scaled = t * (palette.length - 1);
            const i = Math.floor(scaled);
            return targetColor.copy(palette[i]).lerp(palette[i + 1], scaled - i);
        }

        function selectInlet(inlet) {
            if (!inlet) { transformControls.detach(); }
            else {
                transformControls.attach(inlet.mesh);
                transformControls.setMode('translate');
            }
            renderInletList();
        }

        function renderInletList() {
            const list = document.getElementById('inlets-list'); if (!list) return; list.innerHTML = '';
            const btn = document.getElementById('btn-add-inlet'); if (btn) btn.disabled = state.inlets.length >= 4;
            state.inlets.forEach(inlet => {
                const isSelected = transformControls.object === inlet.mesh;
                const item = document.createElement('div');
                item.className = 'inlet-item' + (isSelected ? ' active' : '');
                item.innerHTML = `<span onclick="selectInletById(${inlet.id})">SOURCE_NODE_0${inlet.id}</span><span class="del" onclick="removeInlet(${inlet.id})">DEL</span>`;
                list.appendChild(item);
            });
        }

        // Fixed Scoping for InnerHTML handlers
        window.selectInletById = (id) => selectInlet(state.inlets.find(i => i.id === id));

        window.removeInlet = (id) => {
            const idx = state.inlets.findIndex(i => i.id === id);
            if (idx !== -1) {
                if (transformControls.object === state.inlets[idx].mesh) transformControls.detach();
                scene.remove(state.inlets[idx].mesh);
                state.inlets.splice(idx, 1);
                renderInletList();
            }
        };

        window.toggleBloom = () => { if (bloomPass) bloomPass.enabled = document.getElementById('c-bloom').checked; };
        window.updateBloom = () => {
            if (bloomPass) {
                const val = parseFloat(document.getElementById('i-bloom').value);
                const display = document.getElementById('v-bloom');
                if (display) display.innerText = val.toFixed(2);
                bloomPass.strength = val;
            }
        };
        window.updateColorMap = () => { state.currentColorMap = document.getElementById('s-colormap').value; refreshColors(); };
        window.updatePathStyle = () => {
            state.currentPathStyle = document.getElementById('s-pathstyle').value;
            if (state.lastSourceMap) updateVisualization(state.lastSourceMap, state.lastDists, state.lastParents);
        };
        window.toggleInlets = () => { const visible = document.getElementById('c-inlets').checked; state.inlets.forEach(inlet => inlet.mesh.visible = visible); if (!visible) transformControls.detach(); };
        window.toggleGravityGizmo = () => { const v = document.getElementById('c-gravity').checked; if (gravityGizmo) gravityGizmo.visible = v; if (!v && transformControls.object === gravityGizmo) transformControls.detach(); };
        window.togglePoints = () => { if (state.pointsMesh) state.pointsMesh.visible = document.getElementById('c-pts').checked; };
        window.toggleOrgan = () => { if (state.organMesh) state.organMesh.visible = document.getElementById('c-organ').checked; };
        window.toggleFlow = () => { if (flowSystem) flowSystem.update(); };

        function selectGravityGizmo() { transformControls.attach(gravityGizmo); transformControls.setMode('rotate'); renderInletList(); }

        function refreshColors() {
            if (state.segments.length === 0) return;
            if (vesselSystem) {
                vesselSystem.refreshColors(state.segments, state.maxFlow);
            }
        }

        // --- PARTICLE SYSTEM ---
        class FlowParticleSystem {
            constructor() {
                this.maxParticles = 20000;
                this.dummy = new THREE.Object3D();
                this.mesh = new THREE.InstancedMesh(new THREE.SphereGeometry(1, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffffff }), this.maxParticles);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                this.mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(this.maxParticles * 3), 3);
                this.mesh.frustumCulled = false;
                this.progress = new Float32Array(this.maxParticles).map(() => Math.random());
                this.tempCol = new THREE.Color();
                this.posCache = new THREE.Vector3();
            }
            reset() { this.mesh.count = 0; this.mesh.visible = false; document.getElementById('c-flow').checked = false; }
            show() { this.mesh.visible = true; }
            update() {
                const visible = document.getElementById('c-flow').checked;
                this.mesh.visible = visible;
                if (!visible || !state.segments.length) return;
                const speed = parseFloat(document.getElementById('i-speed').value);
                const exp = parseFloat(document.getElementById('i-profile').value);
                const count = Math.min(state.segments.length, this.maxParticles);
                for (let i = 0; i < count; i++) {
                    const seg = state.segments[i];
                    const vel = (exp < 0 ? Math.pow(seg.r, exp) * 0.2 : Math.pow(seg.r, exp) * 5.0);
                    this.progress[i] = (this.progress[i] + (vel / (seg.len + 0.0001)) * speed) % 1.0;
                    const t = this.progress[i];

                    if (state.currentPathStyle === 'SMOOTH' && seg.spline) {
                        seg.spline.getPoint(t, this.posCache);
                    } else {
                        this.posCache.lerpVectors(seg.p0, seg.p1, t);
                    }

                    this.dummy.position.copy(this.posCache);
                    let s = 0.025 * (1 + Math.log(1 + seg.r * 5));
                    if (seg.isTerminal) s *= (1.0 - t * t);
                    this.dummy.scale.setScalar(s);
                    this.dummy.updateMatrix();
                    this.mesh.setMatrixAt(i, this.dummy.matrix);
                    getGradientColor(Math.pow(Math.min(1.0, seg.flow / (state.maxFlow || 1)), 0.4), this.tempCol);
                    this.tempCol.multiplyScalar(3.0);
                    this.mesh.setColorAt(i, this.tempCol);
                }
                this.mesh.count = count; this.mesh.instanceMatrix.needsUpdate = true; this.mesh.instanceColor.needsUpdate = true;
            }
        }

        // --- VESSEL MESH SYSTEM (Capsule/Tube-based rendering) ---
        class VesselMeshSystem {
            constructor() {
                this.maxSegments = 15000;
                this.dummy = new THREE.Object3D();
                this.geometryType = 'CAPSULE'; // 'CAPSULE' or 'TUBE'

                // Create geometries - both are 1 unit tall along Y, radius 1
                // Capsule: CapsuleGeometry(radius, height, capSegments, radialSegments)
                // Total capsule height = height + 2*radius, so with radius=1, height=1, total = 3
                // We'll create a capsule with radius=0.5 and height=0 to get total height of 1
                this.capsuleGeo = new THREE.CapsuleGeometry(0.5, 0, 4, 8); // radius=0.5, height=0, total height=1
                // Cylinder: height 1, radius 1, closed ends
                this.cylinderGeo = new THREE.CylinderGeometry(0.5, 0.5, 1, 8, 1, false);

                this.material = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    blending: THREE.AdditiveBlending
                });
                this.mesh = new THREE.InstancedMesh(this.capsuleGeo, this.material, this.maxSegments);
                this.mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
                this.mesh.instanceColor = new THREE.InstancedBufferAttribute(new Float32Array(this.maxSegments * 3), 3);
                this.mesh.frustumCulled = false;
                this.mesh.count = 0;

                this.tempCol = new THREE.Color();
                this.p0 = new THREE.Vector3();
                this.p1 = new THREE.Vector3();
                this.dir = new THREE.Vector3();
                this.up = new THREE.Vector3(0, 1, 0);
                this.quaternion = new THREE.Quaternion();
            }

            setGeometryType(type) {
                if (type === this.geometryType) return;
                this.geometryType = type;

                // Swap geometry
                const oldGeo = this.mesh.geometry;
                this.mesh.geometry = (type === 'TUBE') ? this.cylinderGeo : this.capsuleGeo;
                // Don't dispose since we're reusing both
            }

            reset() {
                this.mesh.count = 0;
            }

            updateFromSegments(segments, maxFlow, radiusScale) {
                const count = Math.min(segments.length, this.maxSegments);
                const isSmooth = state.currentPathStyle === 'SMOOTH';

                let idx = 0;
                for (let i = 0; i < count; i++) {
                    const seg = segments[i];

                    if (isSmooth && seg.spline) {
                        // For smooth paths, render multiple segments along the spline
                        const subdivs = 4;
                        for (let j = 0; j < subdivs && idx < this.maxSegments; j++) {
                            const t0 = j / subdivs;
                            const t1 = (j + 1) / subdivs;
                            seg.spline.getPoint(t0, this.p0);
                            seg.spline.getPoint(t1, this.p1);
                            this._setInstance(idx, this.p0, this.p1, seg.r * radiusScale, seg.flow, maxFlow);
                            idx++;
                        }
                    } else {
                        // Straight segment - single instance
                        this.p0.set(seg.p0.x, seg.p0.y, seg.p0.z);
                        this.p1.set(seg.p1.x, seg.p1.y, seg.p1.z);
                        this._setInstance(idx, this.p0, this.p1, seg.r * radiusScale, seg.flow, maxFlow);
                        idx++;
                    }
                }

                this.mesh.count = idx;
                this.mesh.instanceMatrix.needsUpdate = true;
                this.mesh.instanceColor.needsUpdate = true;
            }

            _setInstance(idx, p0, p1, radius, flow, maxFlow) {
                // Calculate direction and length
                this.dir.subVectors(p1, p0);
                const length = this.dir.length();
                if (length < 0.0001) return;

                this.dir.normalize();

                // Position at midpoint between p0 and p1
                this.dummy.position.lerpVectors(p0, p1, 0.5);

                // Orient to point from p0 to p1 (geometry is along Y-axis by default)
                this.quaternion.setFromUnitVectors(this.up, this.dir);
                this.dummy.quaternion.copy(this.quaternion);

                // Scale: both geometries are unit height (1) with base radius 0.5
                // So scale Y by segment length, and X/Z by radius * 2 (since base radius is 0.5)
                const clampedRadius = Math.max(0.01, Math.min(radius, 0.3));
                const radiusScale = clampedRadius * 2; // Scale from 0.5 base to desired radius
                this.dummy.scale.set(radiusScale, length, radiusScale);

                this.dummy.updateMatrix();
                this.mesh.setMatrixAt(idx, this.dummy.matrix);

                // Set color based on flow
                getGradientColor(Math.pow(Math.min(1.0, flow / (maxFlow || 1)), 0.4), this.tempCol);
                this.mesh.setColorAt(idx, this.tempCol);
            }

            refreshColors(segments, maxFlow) {
                const count = this.mesh.count;
                let idx = 0;
                const isSmooth = state.currentPathStyle === 'SMOOTH';

                for (let i = 0; i < segments.length && idx < count; i++) {
                    const seg = segments[i];
                    const subdivs = (isSmooth && seg.spline) ? 4 : 1;

                    for (let j = 0; j < subdivs && idx < count; j++) {
                        getGradientColor(Math.pow(Math.min(1.0, seg.flow / (maxFlow || 1)), 0.4), this.tempCol);
                        this.mesh.setColorAt(idx, this.tempCol);
                        idx++;
                    }
                }
                this.mesh.instanceColor.needsUpdate = true;
            }
        }

        let vesselSystem = null;

        window.updateVesselRadius = () => {
            const val = parseFloat(document.getElementById('i-vesselradius').value);
            const display = document.getElementById('v-vesselradius');
            if (display) display.innerText = val.toFixed(2);

            if (vesselSystem && state.segments.length > 0) {
                vesselSystem.updateFromSegments(state.segments, state.maxFlow, val);
            }
        };

        window.updateVesselGeometry = () => {
            const geoType = document.getElementById('s-vesselgeo').value;
            if (vesselSystem) {
                vesselSystem.setGeometryType(geoType);
                if (state.segments.length > 0) {
                    const radiusScale = parseFloat(document.getElementById('i-vesselradius').value);
                    vesselSystem.updateFromSegments(state.segments, state.maxFlow, radiusScale);
                }
            }
        };

        window.addInlet = () => {
            if (state.inlets.length >= 4) return;
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.15, 32, 32), new THREE.MeshBasicMaterial({ color: 0x00f3ff }));
            mesh.add(new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), new THREE.MeshBasicMaterial({ color: 0x00f3ff, transparent: true, opacity: 0.2, wireframe: true })));
            mesh.position.set(-6, (state.inlets.length * 2) - 2, 0);
            scene.add(mesh);
            state.inlets.push({ mesh, id: ++state.inletCounter });
            renderInletList(); selectInlet(state.inlets[state.inlets.length - 1]);
        };

        window.genVolume = async function genVolume() {
            const nScale = parseFloat(document.getElementById('i-noise').value);
            const type = document.getElementById('s-organ').value;
            let geo = new THREE.IcosahedronGeometry(5, 5);
            const pos = geo.attributes.position, v = new THREE.Vector3();
            for (let i = 0; i < pos.count; i++) {
                v.fromBufferAttribute(pos, i);
                if (type === 'HEART') { v.z *= 0.8; v.x *= 1.5; v.y += (v.x * v.x * 0.15) - 2.0; }
                else if (type === 'KIDNEY') { v.y *= 1.5; v.x += Math.cos(v.y * 0.4) * 1.5; v.z *= 0.7; }
                else if (type === 'MUSCLE') { v.y *= 3.0; v.x *= 0.8; v.z *= 0.8; const taper = Math.max(0.2, 1.0 - (Math.abs(v.y) / 10.0)); v.x *= taper; v.z *= taper; }
                else if (type === 'LIVER') { v.x *= 1.4; v.y *= 0.8; if (v.x > 0) v.y *= 0.6; }
                else if (type === 'SPLEEN') { v.x *= 1.2; v.y *= 1.8; v.z *= 0.6; }
                const n = noise.noise(v.x * 0.15, v.y * 0.15, v.z * 0.15);
                v.multiplyScalar(1 + (n * nScale * 0.2));
                pos.setXYZ(i, v.x, v.y, v.z);
            }
            geo.computeVertexNormals(); geo.computeBoundingBox(); setupVolume(geo);
        }

        function setupVolume(geo) {
            state.segments = []; state.maxFlow = 1;
            if (flowSystem) flowSystem.reset();
            if (vesselSystem) vesselSystem.reset();
            if (state.organMesh) scene.remove(state.organMesh);
            if (state.linesMesh) {
                scene.remove(state.linesMesh);
                state.linesMesh = null;
            }
            if (state.pointsMesh) scene.remove(state.pointsMesh);
            state.organMesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0x00f3ff, wireframe: true, transparent: true, opacity: 0.05 }));
            state.organMesh.visible = document.getElementById('c-organ').checked; scene.add(state.organMesh);
            const box = geo.boundingBox, size = new THREE.Vector3(); box.getSize(size);
            const ray = new THREE.Raycaster(), rayDir = new THREE.Vector3(1, 0, 0), meshD = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ side: THREE.DoubleSide }));
            meshD.updateMatrixWorld();
            const count = parseInt(document.getElementById('i-points').value), pts = [];
            while (pts.length < count) {
                const pVec = new THREE.Vector3(box.min.x + Math.random() * size.x, box.min.y + Math.random() * size.y, box.min.z + Math.random() * size.z);
                ray.set(pVec, rayDir);
                if (ray.intersectObject(meshD).length % 2 === 1) {
                    // store nodes as plain objects (x,y,z,ox,oy,oz,id,neighbors) to match perfusion2 logic
                    const p = { x: pVec.x, y: pVec.y, z: pVec.z, ox: pVec.x, oy: pVec.y, oz: pVec.z, id: pts.length, neighbors: [] };
                    pts.push(p);
                }
            }
            state.nodes = pts;
            const pPos = new Float32Array(pts.length * 3); for (let i = 0; i < pts.length; i++) { pPos[i * 3] = pts[i].x; pPos[i * 3 + 1] = pts[i].y; pPos[i * 3 + 2] = pts[i].z; }
            const pGeo = new THREE.BufferGeometry(); pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            state.pointsMesh = new THREE.Points(pGeo, new THREE.PointsMaterial({ color: 0x445566, size: 0.05, transparent: true, opacity: 0.6 }));
            state.pointsMesh.visible = document.getElementById('c-pts').checked; state.pointsMesh.frustumCulled = false; scene.add(state.pointsMesh);
            const cDistSq = (1.25 * Math.pow(3000 / count, 0.33)) ** 2;
            for (let i = 0; i < pts.length; i++) {
                for (let j = i + 1; j < pts.length; j++) {
                    const dx = pts[i].x - pts[j].x, dy = pts[i].y - pts[j].y, dz = pts[i].z - pts[j].z;
                    const d2 = dx * dx + dy * dy + dz * dz;
                    if (d2 < cDistSq) {
                        const d = Math.sqrt(d2);
                        pts[i].neighbors.push({ to: j, dist: d, cond: 1.0, flow: 0 });
                        pts[j].neighbors.push({ to: i, dist: d, cond: 1.0, flow: 0 });
                    }
                }
            }
            document.getElementById('s-voxels').innerText = pts.length; document.getElementById('btn-grow').disabled = false;
        }

        window.growVessels = async function growVessels() {
            controls.autoRotate = false; transformControls.detach();
            if (state.linesMesh) {
                scene.remove(state.linesMesh);
                state.linesMesh = null;
            }
            if (flowSystem) flowSystem.reset();
            if (vesselSystem) vesselSystem.reset();

            console.log('growVessels: start', { nodes: state.nodes.length, inlets: state.inlets.length });

            // Reset node positions and per-edge conductivity/flow (matches perfusion2 behavior)
            if (state.pointsMesh && state.pointsMesh.geometry && state.pointsMesh.geometry.attributes.position) {
                const posAttr = state.pointsMesh.geometry.attributes.position;
                for (let i = 0; i < state.nodes.length; i++) {
                    const n = state.nodes[i];
                    if (n.ox !== undefined) { n.x = n.ox; n.y = n.oy; n.z = n.oz; }
                    if (n.neighbors) n.neighbors.forEach(e => { e.cond = 1.0; e.flow = 0; });
                    posAttr.setXYZ(i, n.x, n.y, n.z);
                }
                posAttr.needsUpdate = true;
            }

            state.currentPathStyle = document.getElementById('s-pathstyle').value;

            const gStr = parseFloat(document.getElementById('i-g-str').value);
            const gVec = new THREE.Vector3(0, -1, 0); if (gravityGizmo) gVec.applyQuaternion(gravityGizmo.quaternion).normalize();
            const bundle = parseFloat(document.getElementById('i-bundle').value);
            const sourceMap = state.inlets.map(inlet => {
                let minD = Infinity, idx = 0;
                for (let i = 0; i < state.nodes.length; i++) { const d2 = inlet.mesh.position.distanceToSquared(state.nodes[i]); if (d2 < minD) { minD = d2; idx = i; } }
                return { inlet, nodeIdx: idx };
            });
            console.log('growVessels: sourceMap', sourceMap.map(s => ({ id: s.inlet.id, nodeIdx: s.nodeIdx })));
            const sIndices = sourceMap.map(m => m.nodeIdx);
            const tCount = parseInt(document.getElementById('i-targets').value), indices = Array.from({ length: state.nodes.length }, (_, k) => k);
            for (let i = indices.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[indices[i], indices[j]] = [indices[j], indices[i]]; }
            state.targets = indices.slice(0, tCount).filter(id => !sIndices.includes(id));
            console.log('growVessels: targets count', state.targets.length);

            let parents = new Int32Array(state.nodes.length).fill(-1);
            let dists = new Float32Array(state.nodes.length).fill(Infinity);

            for (let iter = 0; iter < 8; iter++) {
                await new Promise(r => setTimeout(r, 10));
                dists.fill(Infinity); parents.fill(-1);
                const visited = new Uint8Array(state.nodes.length).fill(0);
                let active = new Set(); sIndices.forEach(idx => { dists[idx] = 0; active.add(idx); });
                while (active.size > 0) {
                    let u = -1, minD = Infinity; for (let id of active) { if (dists[id] < minD) { minD = dists[id]; u = id; } }
                    if (u === -1) break; active.delete(u); visited[u] = 1;
                    for (let edge of state.nodes[u].neighbors) {
                        if (visited[edge.to]) continue;
                        const dir = new THREE.Vector3(state.nodes[edge.to].x - state.nodes[u].x, state.nodes[edge.to].y - state.nodes[u].y, state.nodes[edge.to].z - state.nodes[u].z).normalize();
                        const penalty = gStr * (1.0 - dir.dot(gVec));
                        const cost = (edge.dist * (1.0 + penalty)) / (1.0 + bundle * edge.cond);
                        if (dists[u] + cost < dists[edge.to]) { dists[edge.to] = dists[u] + cost; parents[edge.to] = u; active.add(edge.to); }
                    }
                }
                for (let n of state.nodes) n.neighbors.forEach(e => e.flow = 0);
                for (let t of state.targets) {
                    let curr = t; while (!sIndices.includes(curr) && curr !== -1) {
                        const p = parents[curr]; if (p === -1) break;
                        state.nodes[p].neighbors.find(e => e.to === curr).flow += 1;
                        state.nodes[curr].neighbors.find(e => e.to === p).flow += 1;
                        curr = p;
                    }
                }
                if (iter < 7) for (let n of state.nodes) n.neighbors.forEach(e => e.cond += e.flow);
                updateVisualization(sourceMap, dists, parents);
            }
            console.log('growVessels: finished iterations; segments', state.segments.length);
            state.lastParents = parents; state.lastDists = dists; state.lastSourceMap = sourceMap;
            document.getElementById('c-flow').disabled = false; document.getElementById('c-flow').checked = true;
            if (flowSystem) flowSystem.show();['btn-exp-vessel', 'btn-exp-obj', 'btn-animate', 'btn-bake-mesh'].forEach(id => document.getElementById(id).disabled = false);
        }

        window.animateGrowth = async function animateGrowth() {
            if (!state.lastParents || !state.lastSourceMap) return;
            document.getElementById('btn-animate').disabled = true;
            const parents = state.lastParents;

            // build endIdx -> segment indices map for O(1) lookups
            const endMap = new Map();
            for (let si = 0; si < state.segments.length; si++) {
                const s = state.segments[si]; if (s.endIdx === undefined) continue;
                if (!endMap.has(s.endIdx)) endMap.set(s.endIdx, []);
                endMap.get(s.endIdx).push(si);
            }

            // build children map from parents array
            const children = new Map();
            for (let i = 0; i < parents.length; i++) { const p = parents[i]; if (p === -1) continue; if (!children.has(p)) children.set(p, []); children.get(p).push(i); }

            // BFS order of segment indices
            const orderedIdx = [];
            const q = [];
            const visited = new Uint8Array(state.nodes.length);
            // add inlet->node segments first and seed queue
            for (const m of state.lastSourceMap) {
                const nodeIdx = m.nodeIdx;
                const segs = endMap.get(nodeIdx) || [];
                for (const si of segs) { const s = state.segments[si]; if (s.p0 && s.p0.isVector3) orderedIdx.push(si); }
                q.push(nodeIdx); visited[nodeIdx] = 1;
            }

            while (q.length) {
                const u = q.shift();
                const ch = children.get(u) || [];
                for (const c of ch) {
                    const segs = endMap.get(c) || [];
                    for (const si of segs) orderedIdx.push(si);
                    if (!visited[c]) { visited[c] = 1; q.push(c); }
                }
            }

            if (orderedIdx.length === 0) { document.getElementById('btn-animate').disabled = false; return; }

            // Reorder segments array to match BFS order
            const reorderedSegments = orderedIdx.map(idx => state.segments[idx]);
            // Add any segments not in orderedIdx (safety)
            const orderedSet = new Set(orderedIdx);
            for (let i = 0; i < state.segments.length; i++) {
                if (!orderedSet.has(i)) reorderedSegments.push(state.segments[i]);
            }
            state.segments = reorderedSegments;

            // Rebuild the vessel mesh with reordered segments (this sets mesh.count to total)
            const radiusScale = parseFloat(document.getElementById('i-vesselradius').value);
            if (vesselSystem) {
                vesselSystem.updateFromSegments(state.segments, state.maxFlow, radiusScale);
            }

            // Calculate instances per segment for animation
            const isSmooth = state.currentPathStyle === 'SMOOTH';
            const subdivs = isSmooth ? 4 : 1;
            let totalInstances = 0;
            for (const s of state.segments) {
                totalInstances += (isSmooth && s.spline) ? subdivs : 1;
            }

            const fullCount = vesselSystem.mesh.count;
            vesselSystem.mesh.count = 0; // Start with nothing visible

            // Animate by progressively increasing mesh.count
            const frames = Math.max(1, parseInt(document.getElementById('i-anim-speed') ? document.getElementById('i-anim-speed').value : 60));
            const speed = Math.max(1, Math.ceil(fullCount / frames));

            return new Promise(resolve => {
                let currentCount = 0;
                function step() {
                    currentCount = Math.min(fullCount, currentCount + speed);
                    vesselSystem.mesh.count = currentCount;
                    vesselSystem.mesh.instanceMatrix.needsUpdate = true;

                    if (currentCount >= fullCount) {
                        document.getElementById('btn-animate').disabled = false;
                        resolve();
                        return;
                    }
                    requestAnimationFrame(step);
                }
                requestAnimationFrame(step);
            });
        };

        function updateVisualization(sourceMap, dists, parents) {
            state.segments = []; let maxF = 0;
            const pathStyle = document.getElementById('s-pathstyle').value;
            state.currentPathStyle = pathStyle;
            const isSmooth = pathStyle === 'SMOOTH';
            const tree = new Map();

            sourceMap.forEach(m => {
                const n = state.nodes[m.nodeIdx]; let f = 0; n.neighbors.forEach(e => f += e.flow);
                if (f > 0) {
                    maxF = Math.max(maxF, f);
                    state.segments.push({ p0: m.inlet.mesh.position, p1: n, flow: f, endIdx: m.nodeIdx, len: m.inlet.mesh.position.distanceTo(n) });
                    if (!tree.has(-100 - m.id)) tree.set(-100 - m.id, []); tree.get(-100 - m.id).push(m.nodeIdx);
                }
            });

            for (let i = 0; i < state.nodes.length; i++) {
                const p = parents[i];
                if (p !== -1) {
                    const edge = state.nodes[i].neighbors.find(e => e.to === p);
                    if (edge && edge.flow > 0) {
                        maxF = Math.max(maxF, edge.flow);
                        state.segments.push({ p0: state.nodes[p], p1: state.nodes[i], flow: edge.flow, endIdx: i, len: edge.dist });
                        if (!tree.has(p)) tree.set(p, []); tree.get(p).push(i);
                    }
                }
            }
            state.maxFlow = maxF;
            state.segments.forEach(s => { s.r = Math.sqrt(s.flow) * 0.06; s.isTerminal = (s.flow <= 1); });

            console.log('updateVisualization: segments built', state.segments.length, 'isSmooth', isSmooth);

            // Build splines for smooth mode
            if (isSmooth) {
                state.segments.forEach(s => {
                    const nodeP = state.nodes.find(n => n.x === s.p0.x && n.y === s.p0.y);
                    const pIdx = nodeP ? state.nodes.indexOf(nodeP) : -1;
                    const gpIdx = (pIdx !== -1) ? parents[pIdx] : -1;

                    const p_minus_1 = gpIdx !== -1 ? state.nodes[gpIdx] : {
                        x: s.p0.x - (s.p1.x - s.p0.x) * 0.5,
                        y: s.p0.y - (s.p1.y - s.p0.y) * 0.5,
                        z: s.p0.z - (s.p1.z - s.p0.z) * 0.5
                    };

                    const children = tree.get(s.endIdx);
                    const p_plus_1 = (children && children.length > 0) ? state.nodes[children[0]] : {
                        x: s.p1.x + (s.p1.x - s.p0.x) * 0.5,
                        y: s.p1.y + (s.p1.y - s.p0.y) * 0.5,
                        z: s.p1.z + (s.p1.z - s.p0.z) * 0.5
                    };

                    const curve = new THREE.CatmullRomCurve3([
                        new THREE.Vector3(p_minus_1.x, p_minus_1.y, p_minus_1.z),
                        new THREE.Vector3(s.p0.x, s.p0.y, s.p0.z),
                        new THREE.Vector3(s.p1.x, s.p1.y, s.p1.z),
                        new THREE.Vector3(p_plus_1.x, p_plus_1.y, p_plus_1.z)
                    ]);
                    s.spline = curve;
                });
            }

            // Update vessel mesh system with capsule rendering
            const radiusScale = parseFloat(document.getElementById('i-vesselradius').value);
            if (vesselSystem) {
                vesselSystem.updateFromSegments(state.segments, state.maxFlow, radiusScale);
            }

            // Hide old line mesh if it exists (we're using capsules now)
            if (state.linesMesh) {
                state.linesMesh.visible = false;
            }

            document.getElementById('s-segs').innerText = state.segments.length;
        }

        window.exportData = (type) => {
            let content = "";
            if (type === 'vessels') content = JSON.stringify(state.segments.map(s => ({ p1: [s.p0.x, s.p0.y, s.p0.z], p2: [s.p1.x, s.p1.y, s.p1.z], flow: s.flow })));
            else { content = "# Vascular Tree OBJ\n"; let vIdx = 1; state.segments.forEach(s => { content += `v ${s.p0.x} ${s.p0.y} ${s.p0.z}\nv ${s.p1.x} ${s.p1.y} ${s.p1.z}\nl ${vIdx} ${vIdx + 1}\n`; vIdx += 2; }); }
            const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([content])); a.download = `vascular_data.${type === 'vessels' ? 'json' : 'obj'}`; a.click();
        };

        // --- SDF MESH BAKING ---
        let bakedMesh = null;

        // Marching Cubes edge table
        const MC_EDGE_TABLE = new Uint16Array([0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0]);

        // Marching Cubes triangle table (simplified - first entry per case)
        const MC_TRI_TABLE = [
            [], [0, 8, 3], [0, 1, 9], [1, 8, 3, 9, 8, 1], [1, 2, 10], [0, 8, 3, 1, 2, 10], [9, 2, 10, 0, 2, 9], [2, 8, 3, 2, 10, 8, 10, 9, 8], [3, 11, 2], [0, 11, 2, 8, 11, 0], [1, 9, 0, 2, 3, 11], [1, 11, 2, 1, 9, 11, 9, 8, 11], [3, 10, 1, 11, 10, 3], [0, 10, 1, 0, 8, 10, 8, 11, 10], [3, 9, 0, 3, 11, 9, 11, 10, 9], [9, 8, 10, 10, 8, 11], [4, 7, 8], [4, 3, 0, 7, 3, 4], [0, 1, 9, 8, 4, 7], [4, 1, 9, 4, 7, 1, 7, 3, 1], [1, 2, 10, 8, 4, 7], [3, 4, 7, 3, 0, 4, 1, 2, 10], [9, 2, 10, 9, 0, 2, 8, 4, 7], [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4], [8, 4, 7, 3, 11, 2], [11, 4, 7, 11, 2, 4, 2, 0, 4], [9, 0, 1, 8, 4, 7, 2, 3, 11], [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1], [3, 10, 1, 3, 11, 10, 7, 8, 4], [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4], [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3], [4, 7, 11, 4, 11, 9, 9, 11, 10], [9, 5, 4], [9, 5, 4, 0, 8, 3], [0, 5, 4, 1, 5, 0], [8, 5, 4, 8, 3, 5, 3, 1, 5], [1, 2, 10, 9, 5, 4], [3, 0, 8, 1, 2, 10, 4, 9, 5], [5, 2, 10, 5, 4, 2, 4, 0, 2], [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8], [9, 5, 4, 2, 3, 11], [0, 11, 2, 0, 8, 11, 4, 9, 5], [0, 5, 4, 0, 1, 5, 2, 3, 11], [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5], [10, 3, 11, 10, 1, 3, 9, 5, 4], [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10], [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3], [5, 4, 8, 5, 8, 10, 10, 8, 11], [9, 7, 8, 5, 7, 9], [9, 3, 0, 9, 5, 3, 5, 7, 3], [0, 7, 8, 0, 1, 7, 1, 5, 7], [1, 5, 3, 3, 5, 7], [9, 7, 8, 9, 5, 7, 10, 1, 2], [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3], [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2], [2, 10, 5, 2, 5, 3, 3, 5, 7], [7, 9, 5, 7, 8, 9, 3, 11, 2], [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11], [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7], [11, 2, 1, 11, 1, 7, 7, 1, 5], [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11], [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0], [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0], [11, 10, 5, 7, 11, 5], [10, 6, 5], [0, 8, 3, 5, 10, 6], [9, 0, 1, 5, 10, 6], [1, 8, 3, 1, 9, 8, 5, 10, 6], [1, 6, 5, 2, 6, 1], [1, 6, 5, 1, 2, 6, 3, 0, 8], [9, 6, 5, 9, 0, 6, 0, 2, 6], [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8], [2, 3, 11, 10, 6, 5], [11, 0, 8, 11, 2, 0, 10, 6, 5], [0, 1, 9, 2, 3, 11, 5, 10, 6], [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11], [6, 3, 11, 6, 5, 3, 5, 1, 3], [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6], [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9], [6, 5, 9, 6, 9, 11, 11, 9, 8], [5, 10, 6, 4, 7, 8], [4, 3, 0, 4, 7, 3, 6, 5, 10], [1, 9, 0, 5, 10, 6, 8, 4, 7], [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4], [6, 1, 2, 6, 5, 1, 4, 7, 8], [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7], [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6], [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9], [3, 11, 2, 7, 8, 4, 10, 6, 5], [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11], [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6], [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6], [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6], [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11], [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7], [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9], [10, 4, 9, 6, 4, 10], [4, 10, 6, 4, 9, 10, 0, 8, 3], [10, 0, 1, 10, 6, 0, 6, 4, 0], [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10], [1, 4, 9, 1, 2, 4, 2, 6, 4], [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4], [0, 2, 4, 4, 2, 6], [8, 3, 2, 8, 2, 4, 4, 2, 6], [10, 4, 9, 10, 6, 4, 11, 2, 3], [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6], [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10], [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1], [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3], [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1], [3, 11, 6, 3, 6, 0, 0, 6, 4], [6, 4, 8, 11, 6, 8], [7, 10, 6, 7, 8, 10, 8, 9, 10], [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10], [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0], [10, 6, 7, 10, 7, 1, 1, 7, 3], [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7], [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9], [7, 8, 0, 7, 0, 6, 6, 0, 2], [7, 3, 2, 6, 7, 2], [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7], [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7], [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11], [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1], [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6], [0, 9, 1, 11, 6, 7], [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0], [7, 11, 6], [7, 6, 11], [3, 0, 8, 11, 7, 6], [0, 1, 9, 11, 7, 6], [8, 1, 9, 8, 3, 1, 11, 7, 6], [10, 1, 2, 6, 11, 7], [1, 2, 10, 3, 0, 8, 6, 11, 7], [2, 9, 0, 2, 10, 9, 6, 11, 7], [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8], [7, 2, 3, 6, 2, 7], [7, 0, 8, 7, 6, 0, 6, 2, 0], [2, 7, 6, 2, 3, 7, 0, 1, 9], [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6], [10, 7, 6, 10, 1, 7, 1, 3, 7], [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8], [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7], [7, 6, 10, 7, 10, 8, 8, 10, 9], [6, 8, 4, 11, 8, 6], [3, 6, 11, 3, 0, 6, 0, 4, 6], [8, 6, 11, 8, 4, 6, 9, 0, 1], [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6], [6, 8, 4, 6, 11, 8, 2, 10, 1], [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6], [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9], [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3], [8, 2, 3, 8, 4, 2, 4, 6, 2], [0, 4, 2, 4, 6, 2], [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8], [1, 9, 4, 1, 4, 2, 2, 4, 6], [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1], [10, 1, 0, 10, 0, 6, 6, 0, 4], [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3], [10, 9, 4, 6, 10, 4], [4, 9, 5, 7, 6, 11], [0, 8, 3, 4, 9, 5, 11, 7, 6], [5, 0, 1, 5, 4, 0, 7, 6, 11], [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5], [9, 5, 4, 10, 1, 2, 7, 6, 11], [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5], [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2], [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6], [7, 2, 3, 7, 6, 2, 5, 4, 9], [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7], [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0], [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8], [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7], [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4], [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10], [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10], [6, 9, 5, 6, 11, 9, 11, 8, 9], [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5], [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11], [6, 11, 3, 6, 3, 5, 5, 3, 1], [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6], [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10], [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5], [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3], [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2], [9, 5, 6, 9, 6, 0, 0, 6, 2], [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8], [1, 5, 6, 2, 1, 6], [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6], [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0], [0, 3, 8, 5, 6, 10], [10, 5, 6], [11, 5, 10, 7, 5, 11], [11, 5, 10, 11, 7, 5, 8, 3, 0], [5, 11, 7, 5, 10, 11, 1, 9, 0], [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1], [11, 1, 2, 11, 7, 1, 7, 5, 1], [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11], [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7], [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2], [2, 5, 10, 2, 3, 5, 3, 7, 5], [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5], [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2], [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2], [1, 3, 5, 3, 7, 5], [0, 8, 7, 0, 7, 1, 1, 7, 5], [9, 0, 3, 9, 3, 5, 5, 3, 7], [9, 8, 7, 5, 9, 7], [5, 8, 4, 5, 10, 8, 10, 11, 8], [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0], [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5], [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4], [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8], [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11], [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5], [9, 4, 5, 2, 11, 3], [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4], [5, 10, 2, 5, 2, 4, 4, 2, 0], [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9], [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2], [8, 4, 5, 8, 5, 3, 3, 5, 1], [0, 4, 5, 1, 0, 5], [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5], [9, 4, 5], [4, 11, 7, 4, 9, 11, 9, 10, 11], [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11], [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11], [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4], [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2], [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3], [11, 7, 4, 11, 4, 2, 2, 4, 0], [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4], [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9], [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7], [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10], [1, 10, 2, 8, 7, 4], [4, 9, 1, 4, 1, 7, 7, 1, 3], [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1], [4, 0, 3, 7, 4, 3], [4, 8, 7], [9, 10, 8, 10, 11, 8], [3, 0, 9, 3, 9, 11, 11, 9, 10], [0, 1, 10, 0, 10, 8, 8, 10, 11], [3, 1, 10, 11, 3, 10], [1, 2, 11, 1, 11, 9, 9, 11, 8], [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9], [0, 2, 11, 8, 0, 11], [3, 2, 11], [2, 3, 8, 2, 8, 10, 10, 8, 9], [9, 10, 2, 0, 9, 2], [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8], [1, 10, 2], [1, 3, 8, 9, 1, 8], [0, 9, 1], [0, 3, 8], []
        ];

        // Distance from point to line segment (for capsule SDF)
        function distPointToSegment(px, py, pz, ax, ay, az, bx, by, bz) {
            const abx = bx - ax, aby = by - ay, abz = bz - az;
            const apx = px - ax, apy = py - ay, apz = pz - az;
            const t = Math.max(0, Math.min(1, (apx * abx + apy * aby + apz * abz) / (abx * abx + aby * aby + abz * abz + 0.0001)));
            const cx = ax + t * abx, cy = ay + t * aby, cz = az + t * abz;
            const dx = px - cx, dy = py - cy, dz = pz - cz;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        // Compute SDF value at a point (distance to nearest vessel surface)
        function computeSdfAt(x, y, z, segments, radiusScale) {
            let minDist = Infinity;
            const isSmooth = state.currentPathStyle === 'SMOOTH';

            for (const seg of segments) {
                const radius = seg.r * radiusScale;

                if (isSmooth && seg.spline) {
                    // Sample spline at multiple points
                    const p0 = new THREE.Vector3(), p1 = new THREE.Vector3();
                    for (let j = 0; j < 4; j++) {
                        seg.spline.getPoint(j / 4, p0);
                        seg.spline.getPoint((j + 1) / 4, p1);
                        const d = distPointToSegment(x, y, z, p0.x, p0.y, p0.z, p1.x, p1.y, p1.z) - radius;
                        if (d < minDist) minDist = d;
                    }
                } else {
                    const d = distPointToSegment(x, y, z, seg.p0.x, seg.p0.y, seg.p0.z, seg.p1.x, seg.p1.y, seg.p1.z) - radius;
                    if (d < minDist) minDist = d;
                }
            }
            return minDist;
        }

        // Generate SDF grid
        function generateSdfGrid(segments, resolution, radiusScale, bounds) {
            const sdf = new Float32Array(resolution * resolution * resolution);
            const stepX = (bounds.max.x - bounds.min.x) / (resolution - 1);
            const stepY = (bounds.max.y - bounds.min.y) / (resolution - 1);
            const stepZ = (bounds.max.z - bounds.min.z) / (resolution - 1);

            for (let z = 0; z < resolution; z++) {
                for (let y = 0; y < resolution; y++) {
                    for (let x = 0; x < resolution; x++) {
                        const px = bounds.min.x + x * stepX;
                        const py = bounds.min.y + y * stepY;
                        const pz = bounds.min.z + z * stepZ;
                        sdf[x + y * resolution + z * resolution * resolution] = computeSdfAt(px, py, pz, segments, radiusScale);
                    }
                }
            }
            return { sdf, stepX, stepY, stepZ };
        }

        // Marching cubes mesh extraction
        function marchingCubes(sdf, resolution, bounds, isoLevel = 0) {
            const vertices = [];
            const stepX = (bounds.max.x - bounds.min.x) / (resolution - 1);
            const stepY = (bounds.max.y - bounds.min.y) / (resolution - 1);
            const stepZ = (bounds.max.z - bounds.min.z) / (resolution - 1);

            function getVal(x, y, z) {
                if (x < 0 || y < 0 || z < 0 || x >= resolution || y >= resolution || z >= resolution) return 1;
                return sdf[x + y * resolution + z * resolution * resolution];
            }

            function vertexInterp(p1, p2, v1, v2) {
                if (Math.abs(isoLevel - v1) < 0.00001) return p1.slice();
                if (Math.abs(isoLevel - v2) < 0.00001) return p2.slice();
                if (Math.abs(v1 - v2) < 0.00001) return p1.slice();
                const mu = (isoLevel - v1) / (v2 - v1);
                return [p1[0] + mu * (p2[0] - p1[0]), p1[1] + mu * (p2[1] - p1[1]), p1[2] + mu * (p2[2] - p1[2])];
            }

            for (let z = 0; z < resolution - 1; z++) {
                for (let y = 0; y < resolution - 1; y++) {
                    for (let x = 0; x < resolution - 1; x++) {
                        const px = bounds.min.x + x * stepX;
                        const py = bounds.min.y + y * stepY;
                        const pz = bounds.min.z + z * stepZ;

                        // Get 8 corner values
                        const v = [
                            getVal(x, y, z), getVal(x + 1, y, z), getVal(x + 1, y, z + 1), getVal(x, y, z + 1),
                            getVal(x, y + 1, z), getVal(x + 1, y + 1, z), getVal(x + 1, y + 1, z + 1), getVal(x, y + 1, z + 1)
                        ];

                        // Calculate cube index
                        let cubeIndex = 0;
                        for (let i = 0; i < 8; i++) if (v[i] < isoLevel) cubeIndex |= (1 << i);

                        if (MC_EDGE_TABLE[cubeIndex] === 0) continue;

                        // Corner positions
                        const p = [
                            [px, py, pz], [px + stepX, py, pz], [px + stepX, py, pz + stepZ], [px, py, pz + stepZ],
                            [px, py + stepY, pz], [px + stepX, py + stepY, pz], [px + stepX, py + stepY, pz + stepZ], [px, py + stepY, pz + stepZ]
                        ];

                        // Interpolate vertices on edges
                        const vertList = new Array(12);
                        if (MC_EDGE_TABLE[cubeIndex] & 1) vertList[0] = vertexInterp(p[0], p[1], v[0], v[1]);
                        if (MC_EDGE_TABLE[cubeIndex] & 2) vertList[1] = vertexInterp(p[1], p[2], v[1], v[2]);
                        if (MC_EDGE_TABLE[cubeIndex] & 4) vertList[2] = vertexInterp(p[2], p[3], v[2], v[3]);
                        if (MC_EDGE_TABLE[cubeIndex] & 8) vertList[3] = vertexInterp(p[3], p[0], v[3], v[0]);
                        if (MC_EDGE_TABLE[cubeIndex] & 16) vertList[4] = vertexInterp(p[4], p[5], v[4], v[5]);
                        if (MC_EDGE_TABLE[cubeIndex] & 32) vertList[5] = vertexInterp(p[5], p[6], v[5], v[6]);
                        if (MC_EDGE_TABLE[cubeIndex] & 64) vertList[6] = vertexInterp(p[6], p[7], v[6], v[7]);
                        if (MC_EDGE_TABLE[cubeIndex] & 128) vertList[7] = vertexInterp(p[7], p[4], v[7], v[4]);
                        if (MC_EDGE_TABLE[cubeIndex] & 256) vertList[8] = vertexInterp(p[0], p[4], v[0], v[4]);
                        if (MC_EDGE_TABLE[cubeIndex] & 512) vertList[9] = vertexInterp(p[1], p[5], v[1], v[5]);
                        if (MC_EDGE_TABLE[cubeIndex] & 1024) vertList[10] = vertexInterp(p[2], p[6], v[2], v[6]);
                        if (MC_EDGE_TABLE[cubeIndex] & 2048) vertList[11] = vertexInterp(p[3], p[7], v[3], v[7]);

                        // Add triangles
                        const tris = MC_TRI_TABLE[cubeIndex];
                        for (let i = 0; i < tris.length; i += 3) {
                            vertices.push(...vertList[tris[i]], ...vertList[tris[i + 1]], ...vertList[tris[i + 2]]);
                        }
                    }
                }
            }
            return new Float32Array(vertices);
        }

        window.bakeSdfMesh = async function () {
            if (state.segments.length === 0) return;

            const resolution = parseInt(document.getElementById('i-sdf-res').value);
            const radiusScale = parseFloat(document.getElementById('i-vesselradius').value);

            // Calculate bounds with padding
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

            for (const seg of state.segments) {
                const r = seg.r * radiusScale;
                minX = Math.min(minX, seg.p0.x - r, seg.p1.x - r);
                minY = Math.min(minY, seg.p0.y - r, seg.p1.y - r);
                minZ = Math.min(minZ, seg.p0.z - r, seg.p1.z - r);
                maxX = Math.max(maxX, seg.p0.x + r, seg.p1.x + r);
                maxY = Math.max(maxY, seg.p0.y + r, seg.p1.y + r);
                maxZ = Math.max(maxZ, seg.p0.z + r, seg.p1.z + r);
            }

            // Add padding
            const pad = 0.5;
            const bounds = {
                min: new THREE.Vector3(minX - pad, minY - pad, minZ - pad),
                max: new THREE.Vector3(maxX + pad, maxY + pad, maxZ + pad)
            };

            console.log('Generating SDF grid...', resolution, 'x', resolution, 'x', resolution);
            await new Promise(r => setTimeout(r, 50));

            const { sdf } = generateSdfGrid(state.segments, resolution, radiusScale, bounds);

            console.log('Running marching cubes...');
            await new Promise(r => setTimeout(r, 50));

            const verts = marchingCubes(sdf, resolution, bounds, 0);

            if (verts.length === 0) {
                console.warn('No mesh generated - check SDF');
                return;
            }

            console.log('Mesh generated:', verts.length / 3, 'vertices,', verts.length / 9, 'triangles');

            // Create mesh
            if (bakedMesh) {
                scene.remove(bakedMesh);
                bakedMesh.geometry.dispose();
            }

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
            geo.computeVertexNormals();

            const mat = new THREE.MeshStandardMaterial({
                color: 0xff4444,
                metalness: 0.3,
                roughness: 0.6,
                side: THREE.DoubleSide
            });

            bakedMesh = new THREE.Mesh(geo, mat);
            bakedMesh.visible = document.getElementById('c-baked').checked;
            scene.add(bakedMesh);

            // Add a light if we haven't already (for the baked mesh to be visible)
            if (!scene.getObjectByName('bakedLight')) {
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(10, 10, 10);
                light.name = 'bakedLight';
                scene.add(light);
            }

            document.getElementById('btn-exp-baked').disabled = false;
            document.getElementById('c-baked').checked = true;
            bakedMesh.visible = true;
        };

        window.toggleBakedMesh = () => {
            if (bakedMesh) bakedMesh.visible = document.getElementById('c-baked').checked;
        };

        window.exportBakedMesh = () => {
            if (!bakedMesh) return;

            const positions = bakedMesh.geometry.attributes.position.array;
            let obj = "# Baked Vessel Mesh\n";

            // Vertices
            for (let i = 0; i < positions.length; i += 3) {
                obj += `v ${positions[i].toFixed(6)} ${positions[i + 1].toFixed(6)} ${positions[i + 2].toFixed(6)}\n`;
            }

            // Faces (triangles)
            for (let i = 0; i < positions.length / 3; i += 3) {
                obj += `f ${i + 1} ${i + 2} ${i + 3}\n`;
            }

            const a = document.createElement('a');
            a.href = URL.createObjectURL(new Blob([obj], { type: 'text/plain' }));
            a.download = 'baked_vessels.obj';
            a.click();
        };

        window.handleFileUpload = (e) => {
            const reader = new FileReader(); reader.onload = (ev) => {
                const geo = new STLLoader().parse(ev.target.result); geo.computeBoundingBox(); geo.center();
                const size = new THREE.Vector3(); geo.boundingBox.getSize(size); const max = Math.max(size.x, size.y, size.z);
                if (max > 10) geo.scale(10 / max, 10 / max, 10 / max); window.run(() => setupVolume(geo));
            };
            reader.readAsArrayBuffer(e.target.files[0]);
        };

        init();
    </script>
</body>

</html>